#!/usr/bin/env bash
#
#  Part of https://github.com/jaclu/olint
#
#  Copyright (c) 2024: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  lists the entire file tree, then does a global
#  reverse sort, in order to process most recently
#  changed files first, disregarding what folder they are in.
#
#  For those file types that a linter is defined, linting is done
#  in the order the files are found. This means the last changed
#  file is the first to be checked.
#

error_msg() {
    #
    #  Display error to /dev/stderr, and exit if exit code > -1
    #
    local msg="$1"
    local exit_code="${2:-1}"

    if [[ -z "$msg" ]]; then
        echo
        echo "error_msg() no param"
        exit 9
    fi
    printf "\n\nERROR: %s\n\n" "$msg" >&2
    [[ "$exit_code" -gt -1 ]] && exit "$exit_code"
}

dbg_print() {
    #
    #  Displays info to /dev/stderr
    #
    local msg="$1"
    local this_debug_level="${2:-1}"
    [[ "$debug_level" -ge "$this_debug_level" ]] || return
    printf "v%s>%*s%s\n" "$this_debug_level" "$dbg_indent" "" "$msg" >&2
}

select_config_dir() {
    #
    #  Selects config location
    #
    if [[ -n "$XDG_CONFIG_HOME" ]]; then
        olint_cfg_dir="$XDG_CONFIG_HOME"/olint
    else
        olint_cfg_dir=~/.config/olint
    fi
    mkdir -p "$olint_cfg_dir" || {
        error_msg "Failed to create folder: $olint_cfg_dir"
    }
}

display_time_elapsed() {
    # echo "=V= tools/utils display_time_elapsed($1, $2) $(date)"
    local duration="$1"
    local label="$2"
    local minutes
    local seconds

    minutes="$((duration / 60))"
    seconds="$((duration - minutes * 60))"

    #  Add zero prefix when < 10
    [[ "$minutes" -gt 0 ]] && [[ "$minutes" -lt 10 ]] && minutes="0$minutes"
    [[ "$seconds" -lt 10 ]] && seconds="0$seconds"

    echo
    echo "display_time_elapsed - Time elapsed: $minutes:$seconds - $label"
    echo
}

get_config() {
    local dbg_indent=$dbg_indent
    local f_config

    dbg_print "get_config()"
    ((dbg_indent++)) # increase indent until this returns

    #
    #  Defaults that can be overriden in config files
    #
    linter_shellcheck=shellcheck
    linter_checkbashisms=checkbashisms
    linter_flake8=flake8
    linter_vale=vale

    excludes=(
        ./.cache.olint
    )           #  Specifix excludes
    prefixes=() # Excludes by prefix
    suffixes=() # Excludes by suffix

    #
    #  handling base configuration
    #
    f_config="$olint_cfg_dir"/config
    [[ -f "$f_config" ]] && {
        dbg_print "base configuration: $f_config"
        # shellcheck source=/dev/null
        source "$f_config" || error_msg "Failed to source default config: $f_config"
    }

    #
    #  handling project configuration
    #
    f_config=".olint.conf"
    if [[ -f "$f_config" ]]; then
        dbg_print "project configuration: $f_config"
        # shellcheck source=/dev/null
        source "$f_config" || error_msg "Failed to source project config: $f_config"
    fi

    dbg_print "---  Configuration used  ---" 2
    dbg_print "linter_shellcheck: $linter_shellcheck" 2
    dbg_print "linter_checkbashisms: $linter_checkbashisms" 2
    dbg_print "linter_flake8: $linter_flake8" 2
    dbg_print "linter_vale: $linter_vale" 2
    dbg_print "prefixes ${prefixes[*]}" 2
    dbg_print "suffixes ${suffixes[*]}" 2
    dbg_print "excludes ${excludes[*]}" 2
}

#===============================================================
#
#   Data Types
#
#===============================================================

string_in_array() {
    #
    #  Function to check if a string is in an array
    #
    local target="$1"
    local array
    local element

    dbg_print "string_in_array()" "$dbglvl_data_types"
    shift
    array=("$@")

    for element in "${array[@]}"; do
        if [[ "$element" == "$target" ]]; then
            return 0 # Found the string in the array
        fi
    done

    return 1 # String not found in the array
}

is_integer() {
    dbg_print "is_integer($1)" "$dbglvl_data_types"
    if [[ $1 =~ ^[0-9]+$ ]]; then
        return 0 # It's an integer
    else
        return 1 # It's not an integer
    fi
}

#===============================================================
#
#   Cache handling
#
#===============================================================

cache_write() {
    dbg_print "cache_write()"

    # abort if not using cache
    $use_cache || {
        dbg_print "  aborting due to not using cache"
        return
    }

    # If no changes have happened, no need to save cache
    $cache_is_changed || {
        dbg_print "  aborting due to no changes"
        return
    }

    # clear previous cache
    echo "$olint_cache_version" >"$f_cache_file"

    # Loop through the array and write all lines in one go
    for key in "${!cache_new[@]}"; do
        value="${cache_new[$key]}"
        echo "$value|$key"
    done >>"$f_cache_file"

    echo
    echo "Saved cache: $f_cache_file"
}

cache_read() {
    #
    #  First line is expected to contain an identifier
    #
    local IFS
    local dbg_indent=$dbg_indent
    local waiting_for_header=true
    local f_name
    local f_date
    local f_mtime

    dbg_print "cache_read()"
    ((dbg_indent++)) # increase indent until this returns

    # abort if not using cache
    $use_cache || {
        dbg_print "  aborting due to not using cache"
        return
    }

    # Check if the file exists and is readable
    if [[ -r "$f_cache_file" ]]; then
        dbg_print "found cache file: $f_cache_file" 3

        # Read each line of the file and add to the array

        while IFS= read -r cached_line; do
            dbg_print "read line: $cached_line" 3
            if $waiting_for_header; then
                [[ "$cached_line" = "$olint_cache_version" ]] || {
                    echo
                    echo "Incorrect cashe version"
                    echo "  expected: [$olint_cache_version]"
                    echo "  found:    [$cached_line]"
                    echo
                    echo "Will ignore this cache and replace it in 3 seconds - hit Ctrl-C to abort!"
                    sleep 3
                    break
                }
                waiting_for_header=false
                dbg_print "found correct header: $olint_cache_version" 3
                continue
            else
                IFS='|' read -r f_mtime f_date f_name <<<"$cached_line"
                cache_old["$f_name"]="$f_mtime|$f_date"
            fi
        done <"$f_cache_file"
    fi
}

get_cache_item() {
    #
    #  Returns true ands sets the following global variables
    #  if item matching f_to_check is present in the old cache
    #
    #   f_name
    #   f_mtime
    #   f_date
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent

    dbg_print "get_cache_item($f_to_check)" "$dbglvl_cache_events_more"
    ((dbg_indent++)) # increase indent until this returns

    [[ -v cache_old["$f_to_check"] ]] || {
        dbg_print "item not found" "$((dbglvl_cache_events_more + 1))"
        return 1 # false
    }
    f_name="$f_to_check"
    IFS='|' read -r f_mtime f_date <<<"${cache_old[$f_name]}"
    return 0 # true
}

filename_is_cached() {
    #
    #  If file was in the old cache and is unchanged, this adds
    #  the entry to the new cache and returns True
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent

    $use_cache || return 1 # False

    dbg_print "filename_is_cached($f_to_check)" \
        "$dbglvl_cache_events_more"
    ((dbg_indent++)) # increase indent until this returns

    #echo ">= filename_is_cached($1)"
    [[ -z "$f_to_check" ]] && error_msg "filename_is_cached() - called without param"

    #
    #  If f_to_check was present the following variables are set:
    #   f_name f_mtime f_date
    #
    get_cache_item "$f_to_check" || return 1 # False
    [[ "$(get_mtime "$f_name" || true)" -eq "$f_mtime" ]] && {
        cache_add "$f_name" "$f_mtime" "$f_date"
        return 0 # true
    }
    return 1 # False
}

cache_add() {
    #
    #  If available, iving f_mtime and f_date saves a recalculation
    #  and boosts performance.
    #
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local f_mtime="$2" # optional param
    local f_date="$3"  # optional param

    dbg_print "cache_add($f_name)" "$dbglvl_cache_events_basic"
    ((dbg_indent++)) # increase indent until this returns

    $use_cache || return
    [[ -z "$f_mtime" ]] && f_mtime="$(get_mtime "$f_name")"
    [[ -z "$f_date" ]] && f_date="$(mtime_2_date "$f_mtime")"

    cache_is_changed=true
    cache_new["$f_name"]="$f_mtime|$f_date"
    dbg_print "added $f_name = $f_mtime|$f_date" "dbglvl_cache_events_more"
}

#===============================================================
#
#   File Age related
#
#===============================================================

recent_enough() {
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local current_time
    local span_in_seconds

    dbg_print "recent_enough()" 8
    ((dbg_indent++)) # increase indent until this returns
    #error_msg "recent $dbg_indent"

    case "$h_max_age" in
    0) return 0 ;;  # Return right away if no max age is used
    -1) return 1 ;; # Always fail in -s mode
    *) ;;
    esac

    [[ "$h_max_age" = "0" ]] && return 0 # True - No time limit

    if [[ -z "$t_cutoff" ]]; then
        #
        #  For performance reasons only calculate once, and
        #  use a global var
        #
        current_time=$(date +%s) # Get current time in seconds since epoch
        span_in_seconds="$((3600 * h_max_age))"
        t_cutoff="$((current_time - span_in_seconds))"
    fi

    # display_file_age "$fname"
    [[ "$(get_mtime "$f_name" || true)" -lt "$t_cutoff" ]] && {
        return 1 # False
    }
    return 0 # True
}

get_mtime() {
    local fname="$1"

    dbg_print "get_mtime($fname)" "$dbglvl_data_types"
    if [[ "$this_uname" == "Darwin" ]]; then
        # macOS version
        stat -f "%m" "$fname"
    else
        # Linux version
        stat -c "%Y" "$fname"
    fi
}

mtime_2_date() {
    local f_mtime
    local as_date

    dbg_print "mtime_2_date($1)" "$dbglvl_data_types"
    if is_integer "$1"; then
        f_mtime="$1"
    else
        # Assume it is a file name
        f_mtime="$(get_mtime "$1"))"
    fi

    case "$this_uname" in
    "Darwin") as_date="$(date -r "$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
    *) as_date="$(date -d "@$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
    esac

    dbg_print "result [$as_date]" "$((dbglvl_data_types + 1))"
    echo "$as_date"
}

#===============================================================
#
#   Linting actions
#
#===============================================================

use_linter() {
    [[ -z "$1" ]] && return 1             # False
    [[ "$1" = "$skip_this" ]] && return 1 # False
    return 0                              # True
}

do_parse_linter_def() {
    #
    #  Handles the different notations
    #   linter_cmd
    #   linter_cmd -with -options
    #   skip_this
    #   ""
    #
    local lint_cmd="$1"
    local task="$2"
    local cmd
    local options
    local verif_cmd

    dbg_print "do_parse_linter_def($lint_cmd,$task)" 2
    if [[ -z "$lint_cmd" ]]; then
        cmd=""
        options=""
    elif [[ "${lint_cmd%"${lint_cmd#?}"}" = "-" ]]; then
        error_msg "linter cmd starts with  [$lint_cmd]" -1
        cmd=""
        options=""
    else
        [[ -n "$task" ]] || error_msg "do_parse_linter_def($lint_cmd) - missing param 2"
        cmd="$(echo "$lint_cmd" | cut -d' ' -f1)"
        options="$(echo "$lint_cmd" | cut -d' ' -f2-)"
    fi

    # if there were no options they will be the same
    [[ "$options" = "$cmd" ]] && options=""

    if [[ -n "$cmd" ]]; then
        verif_cmd="$(command -v "$cmd")" || {
            verif_cmd=""
        }
    else
        verif_cmd=""
    fi
    [[ -z "$verif_cmd" ]] && {
        cmd=""
        options=""
    }

    case "$task" in
    verify)
        [[ -n "$verif_cmd" ]] && [[ -n "$options" ]] && verif_cmd="$verif_cmd $options"
        echo "$verif_cmd"
        ;;

    cmd) echo "$cmd" ;;
    options) echo "$options" ;;
    *) error_msg "do_parse_linter_def() - bad param 1 [$task]" ;;
    esac
    return 0 # True
}

verify_lint_cmd() {
    local lint_cmd="$1"
    local cmd_parsed

    dbg_print "verify_lint_cmd($lint_cmd)" 2

    if cmd_parsed="$(do_parse_linter_def "$lint_cmd" verify)"; then
        echo "$cmd_parsed"
    else
        error_msg "Failed to parse lint cmd: $lint_cmd"
    fi
    dbg_print "- result [$cmd_parsed]"
}

linters_available() {
    #
    #  Scan for and define usable linters
    #
    dbg_print "linters_available()"

    linter_shellcheck="$(verify_lint_cmd "$linter_shellcheck")"
    # dbg_print "after verif linter_shellcheck [$linter_shellcheck]" 0
    linter_checkbashisms="$(verify_lint_cmd "$linter_checkbashisms")"
    linter_flake8="$(verify_lint_cmd "$linter_flake8")"
    linter_vale="$(verify_lint_cmd "$linter_vale")"

}

do_display_linters() {
    local all_excludes
    local all_prefixes
    local all_suffixes

    echo "Linters supported: shellcheck checkbashisms flake8 vale"
    echo "Linters used:"
    use_linter "$linter_shellcheck" && echo "shellcheck:    $linter_shellcheck"
    use_linter "$linter_checkbashisms" && echo "checkbashisms: $linter_checkbashisms"
    use_linter "$linter_flake8" && echo "flake8:        $linter_flake8"
    use_linter "$linter_vale" && echo "vale:          $linter_vale"
    echo

    all_excludes="${excludes[*]}"
    all_prefixes="${prefixes[*]}"
    all_suffixes="${suffixes[*]}"

    if [[ -n "$all_excludes" ]] || [[ -n "$all_prefixes" ]] || [[ -n "$all_suffixes" ]]; then
        echo "===  Filters that will be applied on file names  ==="
        echo
        [[ -n "$all_excludes" ]] && {
            echo "---  Files excluded  ---"
            for excluded_file in "${excludes[@]}"; do
                echo "$excluded_file"
            done
            echo
        }
        [[ -n "$all_prefixes" ]] && {
            echo "---  Prefixes ignored  ---"
            echo "$all_prefixes"
            echo
        }
        [[ -n "$all_suffixes" ]] && {
            echo "---  Duffixes ignored  ---"
            echo "  $all_suffixes"
            echo
        }
    else
        echo "No filtering defined, all files will be processed"
    fi

}

handle_linting_error() {
    #
    #  Either write out allready processed files to cache and then exit
    #  or continue based upon
    #
    $lint_continue && return
    cache_write
    exit 1
}

show_linter_action() {
    #
    #  Display what linter is used and what file is processed
    #
    local fname="$1"
    local file_type="$2"
    local lbl="$3"
    # [[ -n "$file_type" ]] && file_type="$file_type - "
    # echo "$file_typeusing $lbl: $fname"

    # Check if file_type is not empty
    if [[ -n "$file_type" ]]; then
        # Add a space and dash after file_type if it's not empty
        file_type="$file_type -"
    else
        # If file_type is empty, assign 8 spaces
        file_type="        "
    fi

    # Print using printf with fixed-width formatting
    printf "%-8susing %-14s: %s\n" "$file_type" "$lbl" "$fname"
}

#
#  The do_ functions runs one specific linter
#
do_shellcheck() {
    local fname=$1
    local file_type="$2" # optional param describing file type

    dbg_print "do_shellcheck($fname)" "$dbglvl_linting_basic"
    [[ -z "$fname" ]] && error_msg "do_shellcheck() - no paran given!" 1

    use_linter "$linter_shellcheck" || return 1
    show_linter_action "$fname" "$file_type" shellcheck

    eval "$linter_shellcheck" "$fname" || {
        handle_linting_error
        return 1 # False
    }
    return 0 # True
}

do_checkbashisms() {
    local fname="$1"
    local file_type="$2" # optional param describing file type

    dbg_print "do_checkbashisms($fname)" "$dbglvl_linting_details"
    [[ -z "$fname" ]] && error_msg "do_checkbashisms() - no paran given!" 1

    use_linter "$linter_checkbashisms" || return 1
    show_linter_action "$fname" "$file_type" checkbashisms
    #
    #  Dont exit for checkbasims issues, just display them
    #  and do a LF to make the warning stand out
    #
    eval "$linter_checkbashisms" "$fname" || echo
}

do_flake8() {
    local fname="$1"
    local file_type="$2" # optional param describing file type

    dbg_print "do_flake8($fname)" "$dbglvl_linting_details"
    [[ -z "$fname" ]] && error_msg "do_flake8() - no paran given!" 1

    use_linter "$linter_flake8" || return 1 # False
    show_linter_action "$fname" "$file_type" flake8
    eval "$linter_flake8" "$fname" || {
        handle_linting_error
        return 1 # False
    }
    return 0 # True
}

do_vale() {
    local fname="$1"
    local file_type="$2" # optional param describing file type
    local vale_tmp="/tmp/shlchk-vale"

    dbg_print "do_vale($fname) vale[$linter_vale]"
    [[ -z "$fname" ]] && error_msg "do_vale() - no paran given!" 1

    use_linter "$linter_vale" || return 1 # False
    show_linter_action "$fname" "$file_type" vale

    eval "$linter_vale" "$fname" >"$vale_tmp" || {
        cat "$vale_tmp"
        handle_linting_error
        exit 1 # False
    }
    return 0 # True
}

#
#  The lint_ functions processes a specific file type, might use multiple
#  linters, like for posix shells both shellcheck and checkbashisms
#
lint_posix() {
    #
    #  This one uses two linters, but since the 2nd checkbashisms is just
    #  additional info, so if shellcheck is not present abort
    #
    local fname="$1"

    [[ -z "$fname" ]] && error_msg "lint_posix() - no paran given!" 1
    use_linter "$linter_shellcheck" || return 1 # False
    dbg_print "lint_posix($fname)" "$dbglvl_linting_details"

    # echo "using posix: $fname"
    do_shellcheck "$fname" "posix" || return 1    # False
    do_checkbashisms "$fname" "posix" || return 1 # False
    return 0                                      # True
}

lint_bash() {
    local fname="$1"

    [[ -z "$fname" ]] && error_msg "lint_bash() - no paran given!" 1
    use_linter "$linter_shellcheck" || return 1 # False
    dbg_print "lint_bash($fname)" "$dbglvl_linting_details"
    echo "using bash: $fname"
    eval "$linter_shellcheck" "$fname" || return 1 # False
    return 0                                       # True
}

#===============================================================
#
#   Process files
#
#===============================================================

handle_ctrl_c() {
    trap '' INT # abort capturing Ctrl-C
    echo
    echo "Ctrl-C captured, terminating olint"
    echo
    echo "Saving allready checked files to cache"
    cache_write
    exit 1
}

process_file_tree() {
    local dbg_indent=$dbg_indent
    local all_files
    local fname
    local exclude
    local prefix
    local suffix
    local f_type

    dbg_print "process_file_tree()"
    ((dbg_indent++)) # increase indent until this returns

    #
    #  Loop over al files, sorted by file age, newest firtst.
    #  Then identifying filetype using: file -b
    #  grouping by type, and linting files suitable for such
    #  as they come up. Thereby minimizing pointless wait time, since
    #  the file tree is globally sorted by age
    #
    if [[ $this_uname == "Darwin" ]]; then
        # macOS version
        # shellcheck disable=SC2312
        mapfile -t all_files < <(find . -type f -exec stat -f '%m %N' {} \; | sort -n -r -k1,1 | cut -d' ' -f2-)
    else
        # all_files=($(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2))
        # shellcheck disable=SC2312
        mapfile -t all_files < <(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2-)

    fi

    trap 'handle_ctrl_c INT' INT

    for fname in "${all_files[@]}"; do
        # abort after this file
        $abort_after && {
            [[ "$previous_fname" = "./bin_shared/dev/pip-hierarchy2" ]] && break
            previous_fname="$fname"
        }
        [[ -d "$fname" ]] && continue

        for exclude in "${excludes[@]}"; do
            [[ "$fname" == "$exclude" ]] && continue 2
        done

        for prefix in "${prefixes[@]}"; do
            [[ "$fname" == "$prefix"* ]] && continue 2
        done

        for suffix in "${suffixes[@]}"; do
            [[ "$fname" == *"$suffix" ]] && continue 2
        done

        # abort if a time limit was set
        recent_enough "$fname" || {
            # maintain cache items if this run is time limited
            dbg_print "process_file_tree() - to old to be processed" 3
            filename_is_cached "$fname"
            continue
        }

        # skip already checked files

        # # display_file_age "$fname"
        # recent_enough
        # continue

        filename_is_cached "$fname" && {
            echo "no changes: $fname"
            continue
        }

        extension="${fname##*.}"

        case "$extension" in
        py | py3)
            #
            #  Since Markdown files containing Python code gets
            #  identified as Python, extension is used to detect Python
            #
            items_python+=("$fname")
            do_flake8 "$fname" && cache_add "$fname"
            continue
            ;;
        *) ;; # use normal detect: file -b
        esac

        f_type="$(file -b "$fname")"

        #
        #  To handle a new file type, just repeat one of the below blocs
        #  lets say you identify Python files and want to track them
        #  add the file to something like items_python  in order to pressent
        #  them just make a call like this:
        #    list_item_group "Python" "${items_python[@]}"
        #
        if [[ "$f_type" == *"POSIX shell script"* ]]; then
            items_posix+=("$fname")
            lint_posix "$fname" && cache_add "$fname"
            continue
        elif [[ "$f_type" == *"Bourne-Again shell script"* ]]; then
            items_bash+=("$fname")
            do_shellcheck "$fname" "bash" && cache_add "$fname"
            continue
        elif [[ "$f_type" == *"ASCII text"* ]]; then
            #  This must come after items_ucode_esc, otherwise this
            #  very generic string would match most files
            items_ascii+=("$fname")
            do_vale "$fname" "text" && cache_add "$fname"
            continue
        elif [[ "$f_type" == *"Unicode text, UTF-8 text, with escape"* ]] ||
            [[ "$f_type" == *"UTF-8 Unicode text, with escape"* ]]; then
            #  Who might have guessed on MacOS file -b output looks different...
            items_ucode_esc+=("$fname")
            do_vale "$fname" "unicode+esc" && cache_add "$fname"
            continue
        elif [[ "$f_type" == *"Unicode text, UTF-8 text"* ]] ||
            [[ "$f_type" == *"UTF-8 Unicode text"* ]]; then
            #  This must come after items_ucode_esc, otherwise that would eat this
            items_ucode+=("$fname")
            do_vale "$fname" "unicode" && cache_add "$fname"
            continue
        else
            dbg_print "Unsupported file type [$f_type] - $fname" 1
        fi
    done

    trap '' INT # abort capturing Ctrl-C
    cache_write
}

list_item_group() {
    local lbl="$1"
    local items
    local item

    shift
    items=("$@")
    [[ ${#items[@]} -eq 0 ]] && return
    echo
    echo "---  $lbl  ---"
    #  Entirely skip sorting for now
    for item in "${items[@]}"; do
        echo "$item"
    done
}

do_show_stats() {
    #
    #  Display selected file types
    #
    $show_stats || return

    list_item_group posix "${items_posix[@]}"
    list_item_group bash "${items_bash[@]}"

    # list_item_group "ASCII text" "${items_ascii[@]}"
    # list_item_group perl "${items_perl[@]}"
    # list_item_group C "${items_c[@]}"
    # list_item_group makefile "${items_makefile[@]}"
    # list_item_group openrc "${items_openrc[@]}"
    list_item_group "Unicode text, UTF-8 text" "${items_ucode[@]}"
    list_item_group "Unicode text, UTF-8 text, with escape" "${items_ucode_esc[@]}"

    # list_item_group "ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2" "${items_bin32_linux_so[@]}"
    # list_item_group "ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-i386" "${items_bin32_musl[@]}"
    # list_item_group "ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-i386.so.1, with debug_info, not stripped" "${items_bin32_other[@]}"

    #
    #  Unrecognized file types
    #
    # if [[ ${#file_types[@]} -gt 0 ]]; then
    #     list_item_group "Unclassified file types" "${file_types[@]}"
    # fi

    #
    #  Some special cases, that will always be displayed if any such item was found
    #

    # test -d /proc/ish && {
    #
    #  Make sure no bin64 items are pressent!
    #
    # if [[ ${#items_bin64[@]} -gt 0 ]]; then
    #     echo
    #     echo "***  iSH can not run 64-bit bins, this is a problem!  ***"
    #     list_item_group "ELF 64-bit LSB executable" "${items_bin64[@]}"
    # fi
    # }
}

show_help() {
    echo "Usage: $prog_name [-h] [-c] [-l] [-n] [-v] [number]

Lint all files recursively in reverse chronological order.

Available options:

-h, --help        Print this help and exit
-c, --continue    Continue with the next file after linter issues are found.
-l, --linters     List supported and used linters and excluded file patterns.
-n, --nocache     Don't use caching for successfully linted files.
-N, --clearcache  Remove cache file if present.
-v, --verbose     Increase verbosity. Multiple -v flags can be used to
                  increase verbosity level.
number            Only check files changed in the last number hours.

Supported linters: shellcheck, checkbashisms, flake8, vale

If a file is successfully linted, the filename and time of the latest change
are saved in a cache (.cache.olint). Next time olint is run, files that have
not been changed are skipped.

The .olint.conf file can be used to define which linters should be used and
optionally set specific parameters for them. This file can also define which
files should be ignored. See README.md for more information about this file.
"
    exit 0
}

#===============================================================
#
#   Main
#
#===============================================================

prog_name=$(basename "$0")
this_uname="$(uname -s)"

dbg_indent=1 # used to indent printoutd in dbg_print
#
#  Some debug level constants, to make it easier to limit what
#  is displayed
#
dbglvl_cache_events_basic=3
dbglvl_cache_events_more="$((dbglvl_cache_events_basic + 1))"
dbglvl_linting_basic=2
dbglvl_linting_details="$((dbglvl_linting_basic + 1))"
dbglvl_data_types=8

# Will only be updated if cache format is changed
olint_cache_version="olint cache vers 0.2.3"
cache_is_changed=false
f_cache_file=".cache.olint" # mtime|date|fname
declare -A cache_old        # What is read from cache file
declare -A cache_new        # What will be written to cache file

skip_this="skip_this" # used to indicate a linter should not be used

abort_after=false     # (unofficial olint dev) option: -a
lint_continue=false   # option: -c
display_linters=false # option: -l
use_cache=true        # option: -n
show_stats=false      # (unofficial olint dev) option: -s
debug_level=0         # option: -v
h_max_age=0           # no max file age for items to be processed

while [[ -n "$1" ]]; do
    case $1 in

    -h | --help)
        # shellcheck disable=SC2317
        show_help || error_msg "show_help() failure"
        ;;

    -a) abort_after=true ;; # Unofficial option for olint dev

    -c | --continue) lint_continue=true ;;

    -C) # Suport for ./deploy - prints out the config dir
        select_config_dir
        echo "$olint_cfg_dir"
        exit 0
        ;;

    -l | --linters) display_linters=true ;;
    -n | --nocache) use_cache=false ;;

    -N | --clearcache)
        if [[ -f "$f_cache_file" ]]; then
            echo "Removing $f_cache_file"
            rm -f "$f_cache_file"
        else
            echo "No cache found: $f_cache_file"
        fi
        exit 0
        ;;

    -s) # This option is not ready to be used, thus not mentioned in the help
        echo "Will skip any linting, only list files by type"
        h_max_age=-1
        show_stats=true
        ;;

    -v | --verbose) ((debug_level++)) ;;

    *[!0-9]*) error_msg "Unrecognized option: $1" ;;

    *) # only remaining param type is an int
        h_max_age="$1"
        echo "Will only check files changed in the last $h_max_age"
        ;;

    esac
    shift
done

[[ "$debug_level" -gt 0 ]] && echo "Debug lvl is: $debug_level"

select_config_dir
get_config

$lint_continue && echo "Will contine with next file if linter found issues"
$use_cache || echo "Will not use cache for checked files"
echo

linters_available

$display_linters && {
    do_display_linters
    exit 0
}

cache_read
process_file_tree
do_show_stats
