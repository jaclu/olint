#!/usr/bin/env bash
#
#  Part of https://github.com/jaclu/olint
#
#  Copyright (c) 2023,2024: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  lists the entire file tree, then does a global
#  reverse sort, in order to process most recently
#  changed files first, disregarding what folder they are in.
#
#  For those file types that a linter is defined, linting is done
#  in the order the files are found. This means the last changed
#  file is the first to be checked.
#

error_msg() {
    #
    #  Display error, and exit if exit code > -1
    #
    local msg="$1"
    local exit_code="${2:-1}"

    if [[ -z "${msg}" ]]; then
        echo
        echo "error_msg() no param"
        exit 9
    fi
    # trimmed="$(echo -e "$msg" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^\\n*//' -e 's/\\n*$//')"

    printf "\n\nERROR: %s\n\n" "$msg"
    [[ "$exit_code" -gt -1 ]] && exit "$exit_code"
}

display_time_elapsed() {
    # echo "=V= tools/utils display_time_elapsed($1, $2) $(date)"
    local duration="$1"
    local label="$2"
    local minutes
    local seconds

    minutes="$((duration / 60))"
    seconds="$((duration - minutes * 60))"

    #  Add zero prefix when < 10
    [[ "${minutes}" -gt 0 ]] && [[ "${minutes}" -lt 10 ]] && minutes="0${minutes}"
    [[ "${seconds}" -lt 10 ]] && seconds="0${seconds}"

    echo
    echo "display_time_elapsed - Time elapsed: ${minutes}:${seconds} - ${label}"
    echo
}

dbg_print() {
    local msg="$1"
    local this_debug_level="${2:-1}"
    # echo ">> dbg_print lvl [${debug_level}] this msg [${this_debug_level}]" >&2
    [[ "${debug_level}" -ge "${this_debug_level}" ]] || return
    # echo "v${this_debug_level}> ${msg}" >&2
    printf "v%s>%*s%s\n" "${this_debug_level}" "${dbg_indent}" "" "${msg}" >&2
}

get_config() {
    local f_config=".olint.conf"

    dbg_print "get_config()"
    #
    #  Defaults that can be overriden in a project config file
    #

    linter_vale=vale
    linter_shellcheck="shellcheck -x -e SC2312"
    linter_checkbashisms="checkbashisms -n -x"
    linter_flake8=flake8

    #
    #  Specifix excludes
    #
    excludes=(
        ./.cache.olint
    )

    #
    #  Excludes by prefix/suffix
    #
    prefixes=(
        ./.git/
        ./.vscode
    )
    suffixes=(
        \~
        \#
        .pyc
    )

    if [[ -f "${f_config}" ]]; then
        # shellcheck source=/dev/null
        source "${f_config}" || error_msg "Failed to source exclusions: ${f_config}"
        # echo "Config overrides found: ${f_config}"
    fi
}

#===============================================================
#
#   Data Types
#
#===============================================================

string_in_array() {
    #
    #  Function to check if a string is in an array
    #
    local target="$1"
    local array
    local element

    dbg_print "string_in_array()" "${dbglvl_data_types}"
    shift
    array=("$@")

    for element in "${array[@]}"; do
        if [[ "${element}" == "${target}" ]]; then
            return 0 # Found the string in the array
        fi
    done

    return 1 # String not found in the array
}

is_integer() {
    dbg_print "is_integer($1)" "${dbglvl_data_types}"
    if [[ $1 =~ ^[0-9]+$ ]]; then
        return 0 # It's an integer
    else
        return 1 # It's not an integer
    fi
}

#===============================================================
#
#   Cache handling
#
#===============================================================

cache_write() {
    dbg_print "cache_write()"

    # abort if not using cache
    ${use_cache} || return

    # If no changes have happened, no need to save cache
    "${cache_is_changed}" || return

    # clear previous cache
    echo "${olint_cache_version}" >"${f_cache_file}"

    # Loop through the array and write all lines in one go
    for key in "${!cache_new[@]}"; do
        value="${cache_new[${key}]}"
        echo "${value}|${key}"
    done >>"${f_cache_file}"

    echo
    echo "Saved cache: ${f_cache_file}"
}

cache_read() {
    #
    #  First line is expected to contain an identifier
    #
    local IFS
    local dbg_indent=${dbg_indent}
    local waiting_for_header=true
    local f_name
    local f_date
    local f_mtime

    dbg_print "cache_read()"
    ((dbg_indent++)) # increase indent until this returns

    if ${use_cache}; then
        # Check if the file exists and is readable
        if [[ -r "${f_cache_file}" ]]; then
            dbg_print "found cache file: ${f_cache_file}" 3

            # Read each line of the file and add to the array

            while IFS= read -r cached_line; do
                dbg_print "read line: ${cached_line}" 3
                if ${waiting_for_header}; then
                    [[ "${cached_line}" = "${olint_cache_version}" ]] || {
                        echo
                        echo "Incorrect cashe version"
                        echo "  expected: [${olint_cache_version}]"
                        echo "  found:    [${cached_line}]"
                        echo
                        echo "Will ignore this cache and replace it in 3 seconds - hit Ctrl-C to abort!"
                        sleep 3
                        break
                    }
                    waiting_for_header=false
                    dbg_print "found correct header: ${olint_cache_version}" 3
                    continue
                else
                    IFS='|' read -r f_mtime f_date f_name <<<"${cached_line}"
                    cache_old["${f_name}"]="${f_mtime}|${f_date}"
                fi
            done <"${f_cache_file}"
        fi
    else
        [[ -f "${f_cache_file}" ]] && {
            echo "Removed olint cache"
            rm -f "${f_cache_file}"
        }
    fi
}

get_cache_item() {
    #
    #  Returns true ands sets the following global variables
    #  if item matching f_to_check is present in the old cache
    #
    #   f_name
    #   f_mtime
    #   f_date
    #
    local f_to_check="$1"
    local dbg_indent=${dbg_indent}

    dbg_print "get_cache_item(${f_to_check})" "${dbglvl_cashe_events_more}"
    ((dbg_indent++)) # increase indent until this returns

    [[ -v cache_old["${f_to_check}"] ]] || {
        dbg_print "item not found" "$((dbglvl_cashe_events_more + 1))"
        return 1 # false
    }
    f_name="${f_to_check}"
    IFS='|' read -r f_mtime f_date <<<"${cache_old[${f_name}]}"
    return 0 # true
}

filename_is_cached() {
    #
    #  If file was in the old cache and is unchanged, this adds
    #  the entry to the new cache and returns True
    #
    local f_to_check="$1"
    local dbg_indent=${dbg_indent}

    ${use_cache} || return 1 # False

    dbg_print "filename_is_cached(${f_to_check})" \
        "${dbglvl_cashe_events_more}"
    ((dbg_indent++)) # increase indent until this returns

    #echo ">= filename_is_cached($1)"
    [[ -z "${f_to_check}" ]] && error_msg "filename_is_cached() - called without param"

    #
    #  If f_to_check was present the following variables are set:
    #   f_name f_mtime f_date
    #
    get_cache_item "${f_to_check}" || return 1 # False
    [[ "$(get_mtime "${f_name}" || true)" -eq "${f_mtime}" ]] && {
        cache_add "${f_name}" "${f_mtime}" "${f_date}"
        return 0 # true
    }
    return 1 # False
}

cache_add() {
    #
    #  If available, iving f_mtime and f_date saves a recalculation
    #  and boosts performance.
    #
    local dbg_indent=${dbg_indent}
    local f_name="$1"
    local f_mtime="$2" # optional param
    local f_date="$3"  # optional param

    dbg_print "cache_add(${f_name})" "${dbglvl_cashe_events_basic}"
    ((dbg_indent++)) # increase indent until this returns

    ${use_cache} || return
    [[ -z "${f_mtime}" ]] && f_mtime="$(get_mtime "${f_name}")"
    [[ -z "${f_date}" ]] && f_date="$(mtime_2_date "${f_mtime}")"

    cache_is_changed=true
    cache_new["${f_name}"]="${f_mtime}|${f_date}"
    dbg_print "added ${f_name} = ${f_mtime}|${f_date}" "dbglvl_cashe_events_more"
}

#===============================================================
#
#   File Age related
#
#===============================================================

recent_enough() {
    local dbg_indent=${dbg_indent}
    local f_name="$1"
    local current_time
    local span_in_seconds

    dbg_print "recent_enough()" 8
    ((dbg_indent++)) # increase indent until this returns
    #error_msg "recent ${dbg_indent}"

    case "${h_max_age}" in
    0) return 0 ;;  # Return right away if no max age is used
    -1) return 1 ;; # Always fail in -s mode
    *) ;;
    esac

    [[ "${h_max_age}" = "0" ]] && return 0 # True - No time limit

    if [[ -z "${t_cutoff}" ]]; then
        #
        #  For performance reasons only calculate once, and
        #  use a global var
        #
        current_time=$(date +%s) # Get current time in seconds since epoch
        span_in_seconds="$((3600 * h_max_age))"
        t_cutoff="$((current_time - span_in_seconds))"
    fi

    # display_file_age "${fname}"
    [[ "$(get_mtime "${f_name}" || true)" -lt "${t_cutoff}" ]] && {
        return 1 # False
    }
    return 0 # True
}

get_mtime() {
    local fname="$1"

    dbg_print "get_mtime(${fname})" "${dbglvl_data_types}"
    if [[ "${this_uname}" == "Darwin" ]]; then
        # macOS version
        stat -f "%m" "${fname}"
    else
        # Linux version
        stat -c "%Y" "${fname}"
    fi
}

mtime_2_date() {
    local f_mtime
    local as_date

    dbg_print "mtime_2_date($1)" "${dbglvl_data_types}"
    if is_integer "$1"; then
        f_mtime="$1"
    else
        # Assume it is a file name
        f_mtime="$(get_mtime "$1"))"
    fi

    case "${this_uname}" in
    "Darwin") as_date="$(date -r "${f_mtime}" +'%Y-%m-%d %H:%M:%S')" ;;
    *) as_date="$(date -d "@${f_mtime}" +'%Y-%m-%d %H:%M:%S')" ;;
    esac

    dbg_print "result [${as_date}]" "$((dbglvl_data_types + 1))"
    echo "${as_date}"
}

#===============================================================
#
#   Linting actions
#
#===============================================================

use_linter() {
    [[ "$1" = "${skip_this}" ]] && return 1 # False
    [[ -z "$1" ]] && error_msg "use_linter() - no param"
    return 0 # True
}

parse_lint_def() {
    local lint_cmd="$1"
    local task="$2"
    local cmd
    local options
    local verif_cmd

    [[ -n "${task}" ]] || error_msg "parse_lint_def() - missing param 1"
    [[ -n "${lint_cmd}" ]] || error_msg "parse_lint_def() - missing param 2"
    dbg_print "parse_lint_def()" 2
    cmd="$(echo "${lint_cmd}" | cut -d' ' -f1)"
    options="$(echo "${lint_cmd}" | cut -d' ' -f2-)"

    # if there were no options they will be the same
    [[ "${options}" = "${cmd}" ]] && options=""

    verif_cmd="$(command -v "${cmd}")" || verif_cmd="${skip_this}"

    case "$task" in
    verify)
        if use_linter "${verif_cmd}"; then
            echo "${verif_cmd} ${options}"
        else
            echo "${verif_cmd}"
        fi
        ;;

    cmd) echo "${cmd}" ;;
    options) echo "${options}" ;;
    *) error_msg "parse_lint_def() - bad param 1 [$task]" ;;
    esac
    return 0 # True
}

identify_available_linters() {
    #
    #  Scan for and define usable linters
    #

    dbg_print "identify_available_linters()"

    # echo
    # echo "loop"
    # for param in "cmd" "options" "verify"; do
    #     echo "# ${param}   [$(parse_lint_def "${linter_shellcheck}" "${param}")]"
    # done
    # error_msg "loop done"

    linter_shellcheck="$(parse_lint_def "${linter_shellcheck}" verify)" || error_msg "${linter_shellcheck}"
    linter_checkbashisms="$(parse_lint_def "${linter_checkbashisms}" verify)" || error_msg "${linter_checkbashisms}"
    linter_flake8="$(parse_lint_def "${linter_flake8}" verify)" || error_msg "${linter_flake8}"
    linter_vale="$(parse_lint_def "${linter_vale}" verify)" || error_msg "${linter_vale}"

    echo "Linters supported: shellcheck checkbashisms flake8 vale"
    echo "Linters used:"
    use_linter "${linter_shellcheck}" && echo "shellcheck:    ${linter_shellcheck}"
    use_linter "${linter_checkbashisms}" && echo "checkbashisms: ${linter_checkbashisms}"
    use_linter "${linter_flake8}" && echo "flake8:        ${linter_flake8}"
    use_linter "${linter_vale}" && echo "vale:          ${linter_vale}"
    echo
}

handle_linting_error() {
    ${lint_continue} && return
    cache_write
    exit 1
}

display_linter_used() {
    local fname="$1"
    local file_type="$2"
    local lbl="$3"
    # [[ -n "${file_type}" ]] && file_type="${file_type} - "
    # echo "${file_type}using ${lbl}: ${fname}"

    # Check if file_type is not empty
    if [ -n "${file_type}" ]; then
        # Add a space and dash after file_type if it's not empty
        file_type="${file_type} -"
    else
        # If file_type is empty, assign 8 spaces
        file_type="        "
    fi

    # Print using printf with fixed-width formatting
    printf "%-8susing %-14s: %s\n" "${file_type}" "${lbl}" "${fname}"
}

#
#  The do_ functions runs one specific linter
#
do_shellcheck() {
    local fname=$1
    local file_type="$2" # optional param describing file type

    dbg_print "do_shellcheck(${fname})" "${dbglvl_linting_basic}"
    [[ -z "${fname}" ]] && error_msg "do_shellcheck() - no paran given!" 1

    use_linter "${linter_shellcheck}" || return 1
    display_linter_used "${fname}" "${file_type}" shellcheck

    eval "${linter_shellcheck}" "${fname}" || {
        handle_linting_error
        return 1 # False
    }
    return 0 # True
}

do_checkbashisms() {
    local fname="$1"
    local file_type="$2" # optional param describing file type

    dbg_print "do_checkbashisms(${fname})" "${dbglvl_linting_details}"
    [[ -z "${fname}" ]] && error_msg "do_checkbashisms() - no paran given!" 1

    use_linter "${linter_checkbashisms}" || return 1
    display_linter_used "${fname}" "${file_type}" checkbashisms
    #
    #  Dont exit for checkbasims issues, just display them
    #  and do a LF to make the warning stand out
    #
    eval "${linter_checkbashisms}" "${fname}" || echo
}

do_flake8() {
    local fname="$1"
    local file_type="$2" # optional param describing file type

    dbg_print "do_flake8(${fname})" "${dbglvl_linting_details}"
    [[ -z "${fname}" ]] && error_msg "do_flake8() - no paran given!" 1

    use_linter "${linter_flake8}" || return 1 # False
    display_linter_used "${fname}" "${file_type}" flake8
    eval "${linter_flake8}" "${fname}" || {
        handle_linting_error
        return 1 # False
    }
    return 0 # True
}

do_vale() {
    local fname="$1"
    local file_type="$2" # optional param describing file type
    local vale_tmp="/tmp/shlchk-vale"

    dbg_print "do_vale(${fname}) vale[${linter_vale}]"
    [[ -z "${fname}" ]] && error_msg "do_vale() - no paran given!" 1

    use_linter "${linter_vale}" || return 1 # False
    display_linter_used "${fname}" "${file_type}" vale

    eval "${linter_vale}" "${fname}" >"${vale_tmp}" || {
        cat "${vale_tmp}"
        handle_linting_error
        exit 1 # False
    }
    return 0 # True
}

#
#  The lint_ functions processes a specific file type, might use multiple
#  linters, like for posix shells both shellcheck and checkbashisms
#
lint_posix() {
    #
    #  This one uses two linters, but since the 2nd checkbashisms is just
    #  additional info, so if shellcheck is not present abort
    #
    local fname="$1"

    [[ -z "${fname}" ]] && error_msg "lint_posix() - no paran given!" 1
    use_linter "${linter_shellcheck}" || return 1 # False
    dbg_print "lint_posix(${fname})" "${dbglvl_linting_details}"

    # echo "using posix: ${fname}"
    do_shellcheck "${fname}" "posix" || return 1    # False
    do_checkbashisms "${fname}" "posix" || return 1 # False
    return 0                                        # True
}

lint_bash() {
    local fname="$1"

    [[ -z "${fname}" ]] && error_msg "lint_bash() - no paran given!" 1
    use_linter "${linter_shellcheck}" || return 1 # False
    dbg_print "lint_bash(${fname})" "${dbglvl_linting_details}"
    echo "using bash: ${fname}"
    eval "${linter_shellcheck}" "${fname}" || return 1 # False
    return 0                                           # True
}

#===============================================================
#
#   Process files
#
#===============================================================

handle_ctrl_c() {
    trap '' INT # abort capturing Ctrl-C
    echo
    echo "Ctrl-C captured, terminating olint"
    echo
    echo "Saving allready checked files to cache"
    cache_write
    exit 1
}

process_file_tree() {
    local dbg_indent=${dbg_indent}
    local all_files
    local fname
    local exclude
    local prefix
    local suffix
    local f_type

    dbg_print "process_file_tree()"
    ((dbg_indent++)) # increase indent until this returns

    #
    #  Loop over al files, sorted by file age, newest firtst.
    #  Then identifying filetype using: file -b
    #  grouping by type, and linting files suitable for such
    #  as they come up. Thereby minimizing pointless wait time, since
    #  the file tree is globally sorted by age
    #
    if [[ ${this_uname} == "Darwin" ]]; then
        # macOS version
        # shellcheck disable=SC2312
        mapfile -t all_files < <(find . -type f -exec stat -f '%m %N' {} \; | sort -n -r -k1,1 | cut -d' ' -f2-)
    else
        # all_files=($(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2))
        # shellcheck disable=SC2312
        mapfile -t all_files < <(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2-)

    fi

    trap 'handle_ctrl_c INT' INT

    for fname in "${all_files[@]}"; do
        # abort after this file
        ${abort_after} && {
            [[ "${previous_fname}" = "./bin_shared/dev/pip-hierarchy2" ]] && break
            previous_fname="${fname}"
        }
        [[ -d "${fname}" ]] && continue

        for exclude in "${excludes[@]}"; do
            [[ "${fname}" == "${exclude}" ]] && continue 2
        done

        for prefix in "${prefixes[@]}"; do
            [[ "${fname}" == "${prefix}"* ]] && continue 2
        done

        for suffix in "${suffixes[@]}"; do
            [[ "${fname}" == *"${suffix}" ]] && continue 2
        done

        # abort if a time limit was set
        recent_enough "${fname}" || {
            # maintain cache items if this run is time limited
            dbg_print "process_file_tree() - to old to be processed" 3
            filename_is_cached "${fname}"
            continue
        }

        # skip already checked files

        # # display_file_age "${fname}"
        # recent_enough
        # continue

        filename_is_cached "${fname}" && {
            echo "no changes: ${fname}"
            continue
        }

        extension="${fname##*.}"
        case "${extension}" in
        py | py3)
            #
            #  Since Markdown files containing Python code gets
            #  identified as Python, extension is used to detect Python
            #
            items_python+=("${fname}")
            do_flake8 "${fname}" && cache_add "${fname}"
            continue
            ;;
        *) ;; # use normal detect: file -b
        esac

        f_type="$(file -b "${fname}")"

        #
        #  To handle a new file type, just repeat one of the below blocs
        #  lets say you identify Python files and want to track them
        #  add the file to something like items_python  in order to pressent
        #  them just make a call like this:
        #    list_item_group "Python" "${items_python[@]}"
        #
        if [[ "${f_type}" == *"POSIX shell script"* ]]; then
            items_posix+=("${fname}")
            lint_posix "${fname}" && cache_add "${fname}"
            continue
        elif [[ "${f_type}" == *"Bourne-Again shell script"* ]]; then
            items_bash+=("${fname}")
            do_shellcheck "${fname}" "bash" && cache_add "${fname}"
            continue
        elif [[ "${f_type}" == *"ASCII text"* ]]; then
            #  This must come after items_ucode_esc, otherwise this
            #  very generic string would match most files
            items_ascii+=("${fname}")
            do_vale "${fname}" "text" && cache_add "${fname}"
            continue
        elif [[ "${f_type}" == *"Unicode text, UTF-8 text, with escape"* ]] ||
            [[ "${f_type}" == *"UTF-8 Unicode text, with escape"* ]]; then
            #  Who might have guessed on MacOS file -b output looks different...
            items_ucode_esc+=("${fname}")
            do_vale "${fname}" "unicode+esc" && cache_add "${fname}"
            continue
        elif [[ "${f_type}" == *"Unicode text, UTF-8 text"* ]] ||
            [[ "${f_type}" == *"UTF-8 Unicode text"* ]]; then
            #  This must come after items_ucode_esc, otherwise that would eat this
            items_ucode+=("${fname}")
            do_vale "${fname}" "unicode" && cache_add "${fname}"
            continue
        else
            dbg_print "Unsupported file type [$f_type] - ${fname}" 1
        fi
    done

    trap '' INT # abort capturing Ctrl-C
    cache_write
}

list_item_group() {
    local lbl="$1"
    local items
    local item

    shift
    items=("$@")
    [[ ${#items[@]} -eq 0 ]] && return
    echo
    echo "---  ${lbl}  ---"
    #  Entirely skip sorting for now
    for item in "${items[@]}"; do
        echo "${item}"
    done
}

do_show_stats() {
    #
    #  Display selected file types
    #
    ${show_stats} || return

    list_item_group posix "${items_posix[@]}"
    list_item_group bash "${items_bash[@]}"

    # list_item_group "ASCII text" "${items_ascii[@]}"
    # list_item_group perl "${items_perl[@]}"
    # list_item_group C "${items_c[@]}"
    # list_item_group makefile "${items_makefile[@]}"
    # list_item_group openrc "${items_openrc[@]}"
    list_item_group "Unicode text, UTF-8 text" "${items_ucode[@]}"
    list_item_group "Unicode text, UTF-8 text, with escape" "${items_ucode_esc[@]}"

    # list_item_group "ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2" "${items_bin32_linux_so[@]}"
    # list_item_group "ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-i386" "${items_bin32_musl[@]}"
    # list_item_group "ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-musl-i386.so.1, with debug_info, not stripped" "${items_bin32_other[@]}"

    #
    #  Unrecognized file types
    #
    # if [[ ${#file_types[@]} -gt 0 ]]; then
    #     list_item_group "Unclassified file types" "${file_types[@]}"
    # fi

    #
    #  Some special cases, that will always be displayed if any such item was found
    #

    # test -d /proc/ish && {
    #
    #  Make sure no bin64 items are pressent!
    #
    # if [[ ${#items_bin64[@]} -gt 0 ]]; then
    #     echo
    #     echo "***  iSH can not run 64-bit bins, this is a problem!  ***"
    #     list_item_group "ELF 64-bit LSB executable" "${items_bin64[@]}"
    # fi
    # }
}

show_help() { # Multi OK 1
    echo "Usage: ${prog_name} [-h] [-c] [-l] [-n] [-v] [number]

Available options:

-h  --help      Print this help and exit
-c  --continue  Continues with next file after linter issues are found.
-l  --linters   Lists supported and available linters.
-n  --nocache   Don't use caching for successfully linted files.
-v  --verbose   increase verbosity, multiple -v can be used to
                increase verbosity level.
number          Only check files changed in the last number hours.

lints all files recursevly in reverse chronological order

If a file is succeefully linted, filename and time of latest change is
saved in a cache (.cache.olint).
Next time olint is run files that have not been changed are skipped.

Linters supported: shellcheck, checkbashisms, flake8, vale

.olint.conf can be used to define files that should not be linted,
see README.md for more info about this file.
"
    exit 0
}

#===============================================================
#
#   Main
#
#===============================================================

debug_level=0
dbg_indent=1 # used to indent calls from within a "parrent" func
#
#  Some debug level constants, to make it easier to limit what
#  is displayed
#
dbglvl_cashe_events_basic=3
dbglvl_cashe_events_more="$((dbglvl_cashe_events_basic + 1))"
dbglvl_linting_basic=2
dbglvl_linting_details="$((dbglvl_linting_basic + 1))"
dbglvl_data_types=8

# Will only be updated if cache format is changed
olint_cache_version="olint cache vers 0.2.3"
use_cache=true #    cache is disabled by option: -C
cache_is_changed=false
f_cache_file=".cache.olint" # mtime|date|fname
declare -A cache_old        # What is read from cache file
declare -A cache_new        # What will be written to cache file

this_uname="$(uname -s)"

skip_this="skip_this"
h_max_age=0         # no max time
abort_after=false   # abort after is incomplete: -a
lint_continue=false # continue with next file on linter issues -c
show_stats=false    # filetype summary is enabled by option: -s

prog_name=$(basename "$0")

get_config

while [[ -n "$1" ]]; do
    case $1 in

    -h | --help)
        # shellcheck disable=SC2317
        show_help || error_msg "show_help() failure"
        ;;

    #
    #  Debuging option, not meant to be used outside olint dev
    #
    -a) abort_after=true ;;

    -c)
        echo "Will contine with next file if linter found issues"
        lint_continue=true
        ;;

    -l | --linters)
        identify_available_linters
        exit 0
        ;;

    -n | --nocache)
        echo "Will not use cache for checked files"
        use_cache=false
        ;;

    -s) # This option is not ready to be used, thus not mentioned in the help
        echo "Will skip any linting, only list files by type"
        h_max_age=-1
        show_stats=true
        ;;

    -v | --verbose) ((debug_level++)) ;;

    *[!0-9]*) error_msg "Unrecognized option: $1" ;;

    *) # only remaining param type is an int
        h_max_age="$1"
        echo "Will only check files changed in the last ${h_max_age}h"
        ;;

    esac
    shift
done

[[ "${debug_level}" -gt 0 ]] && echo "Verbose lvel is: ${debug_level}"

identify_available_linters
cache_read
process_file_tree
do_show_stats
