#!/usr/bin/env bash
#
#  Part of https://github.com/jaclu/olint
#
#  Copyright (c) 2024: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  lists the entire file tree, then does a global
#  reverse sort, in order to process most recently
#  changed files first, disregarding what folder they are in.
#
#  For those file types that a linter is defined, linting is done
#  in the order the files are found. This means the last changed
#  file is the first to be checked.
#
#

should_project_be_ignored() {
    #  Abort Check
    case "$(lowercase_it "$ignore_project")" in
    1 | "true" | "yes")
        echo "olint - Project ignored due to ignore_project=$ignore_project"
        echo "        Defined in: $olint_cfg_proj"
        env_cleanup 0
        ;;
    *) ;;
    esac
}

error_msg() {
    #
    #  Display error to /dev/stderr, and exit if exit code > -1
    #
    local msg="$1"
    local exit_code="${2:-1}"

    if [[ -z "$msg" ]]; then
        echo
        echo "error_msg() no param"
        env_cleanup 9
    fi
    # shellcheck disable=SC2059 # msg needs to be allowed go contain \n
    printf "\\n\\nERROR: $msg\\n\\n" >&2
    [[ "$exit_code" -gt -1 ]] && env_cleanup "$exit_code"
}

dbg_print() {
    #
    #  Displays info to /dev/stderr, if 2nd param is: forced
    #  This will always be printed, practical to use early on in the
    #  program before verbosity_lvl & dbg_indent has been defined
    #  For such line, comment them out if not desired
    #
    local msg="$1"
    local this_verbose_level="${2:-1}"
    [[ "$this_verbose_level" = "forced" ]] && {
        local this_verbose_level=1
        local verbosity_lvl="$this_verbose_level"
        local dbg_indent=1
    }
    [[ "$verbosity_lvl" -lt "$this_verbose_level" ]] && return
    printf "%s>%*s%s\\n" "$this_verbose_level" "$dbg_indent" "" "$msg" >&2
}

env_cleanup() {
    #
    #  Call this instead of exit, to ensure any cleanup will happen
    #    0 - no errors
    #    1 - did Ctrl-C
    #    2 - linting error
    #    9 - error_msg no param
    #
    #
    ex_code="${1:-1}"
    cache_write
    rm -f "$f_linter_output"
    [[ $ex_code -gt 1 ]] && {
        echo
        echo "*****  olint exited with an error  *****"
    }
    exit "$ex_code"
}

source_file() {
    #  Source a file, exit with error on failure
    local fname="$1"
    local dbg_indent=$dbg_indent

    dbg_print "source_file($fname)" 3
    # only indent if func name is displayed
    [[ "$verbosity_lvl" -gt 2 ]] && ((dbg_indent++))

    if [[ -f "$fname" ]]; then
        # shellcheck source=/dev/null
        source "$fname" || error_msg "Failed to source: $fname"
        dbg_print "Sourced: $fname" 2
        return 0
    else
        dbg_print "source_file() - File not found: $fname" 1
    fi
    return 1
}

parse_cmd_line() {
    local cache_folders d_ceche_folder

    # dbg_print "parse_cmd_line()" forced
    while [[ -n "$1" ]]; do
        case $1 in

        -h | --help)
            #
            # only toggle a switch now, help will be displayed after
            # git_config is called
            #
            # shellcheck disable=SC2317
            do_show_help=true
            ;;

        -c | --config) show_config=true ;;

        -C | --continue) lint_continue=true ;;

        --config-dir) # Suport for ./deploy - prints out the config dir
            echo "$olint_cfg_dir"
            exit 0
            ;;

        -e | --excluded)
            show_excluded=true
            skip_common_excludes=true
            ;;
        -E | --excluded-all)
            show_excluded=true
            skip_common_excludes=false
            ;;
        -m | --mime-type) mime_type_limit=true ;;
        -n | --no-linter) do_lint_files=false ;;
        -N | --nocache) use_cache=false ;;

        -s | --conffig-short)
            show_config=true
            show_config_short=true
            ;;

        -v | --verbose)
            lvl="${2:-missing param}"
            [[ "$lvl" = "missing param" ]] && {
                error_msg "-v/--verbose without verbosity lvl param"
            }
            is_integer "$lvl" || error_msg "verbosity_lvl is not int: [$lvl]"
            verbosity_lvl="$lvl"
            shift # pop debug level
            ;;

        -z | --zapcache)
            if [[ -f "$f_cache_file" ]]; then
                #  Will only attempt to remove the "local" same folder cache file
                echo "Removing $f_cache_file"
                rm -f "$f_cache_file"
            fi
            cache_folders=(
                .mypy_cache
                .pytest_cache
                .ruff_cache
            )
            for d_ceche_folder in "${cache_folders[@]}"; do
                if [[ -d "$d_ceche_folder" ]]; then
                    echo "Removing: $d_ceche_folder"
                    rm -rf "$d_ceche_folder"
                fi
            done
            env_cleanup 0
            ;;

        *[!0-9]*) error_msg "Unrecognized option: $1" ;;

        *) # only remaining param type is an int
            h_max_age="$1"
            echo "Will only check files changed in the last $h_max_age hours"
            ;;

        esac
        shift
    done
}

get_project_config() {
    local dbg_indent=$dbg_indent

    dbg_print "get_project_config()" 2
    ((dbg_indent++)) # increase indent until this returns

    # Traverse up until a project conf is found
    olint_cfg_proj=""
    dir=$(pwd)

    # Traverse up the directory tree
    while [[ "$dir" != "/" ]]; do
        olint_cfg_proj="$dir"/"$bname_proj_config"
        dbg_print "Checking for config in: $dir" 2
        if [[ -f "$olint_cfg_proj" ]]; then
            source_file "$olint_cfg_proj" || olint_cfg_proj="" || {
                error_msg "Failed to source Project config: $olint_cfg_proj"
            }
            [[ -n "$plugin_dir" ]] && {
                local msg="Obsolete config variable found in: $olint_cfg_proj\n"
                msg+="\n  plugin_dir should be replaced by olint_plugin_dir"
                error_msg "$msg"
            }
            dbg_print "Using Project file: $olint_cfg_proj" 1
            f_cache_file="$dir/$bname_cache"
            dbg_print "Will use cache file: $f_cache_file" 1
            return
        fi
        dir=$(dirname "$dir")
    done
    olint_cfg_proj=""
    dbg_print "get_project_config() - No Project config (.olint_conf) found!" 1
}

de_duplicate_exclude_lists() {
    read -r -a excluded_patterns <<<"$(filter_duplicates "${excluded_patterns[@]}")"
    read -r -a hidden_patterns <<<"$(filter_duplicates "${hidden_patterns[@]}")"
    read -r -a excluded_basenames <<<"$(filter_duplicates "${excluded_basenames[@]}")"
    read -r -a excludes <<<"$(filter_duplicates "${excludes[@]}")"
    read -r -a prefixes <<<"$(filter_duplicates "${prefixes[@]}")"
    read -r -a suffixes <<<"$(filter_duplicates "${suffixes[@]}")"
}

filter_duplicates() {
    # Take the input array as a parameter
    local input_array=("$@")

    # Declare a local associative array to store unique elements
    declare -A seen

    # Declare a new array to hold the unique values
    local unique_array=()

    # Iterate over the input array
    for value in "${input_array[@]}"; do
        if [[ -z "${seen[$value]}" ]]; then
            # If the value hasn't been seen yet, add it to the unique_array
            unique_array+=("$value")
            # Mark the value as seen
            seen[$value]=1
        fi
    done

    # Output the unique array
    echo "${unique_array[@]}"
}

filter_hidden_vs_actually_excluded_patterns() {
    local tmp_hidden lst_h item_h lst_e item_e

    [[ ${#hidden_patterns[@]} -eq 0 ]] || [[ ${#excluded_patterns[@]} -eq 0 ]] && {
        return # Either list was empty
    }

    # echo "><> Initial Hidden patterns:"
    # lst="${hidden_patterns[*]}"
    # for item in $lst; do
    #     echo "  $item"
    # done

    tmp_hidden=("${hidden_patterns[@]}")
    hidden_patterns=()
    lst_h="${tmp_hidden[*]}"
    for item_h in $lst_h; do
        lst_e="${excluded_patterns[*]}"
        for item_e in $lst_e; do
            if [[ "$item_h" = "$item_e" ]]; then
                hidden_patterns+=("$item_h")
                break
            fi
        done
    done
}

get_config() {
    local dbg_indent=$dbg_indent

    dbg_print "get_config()" 2
    ((dbg_indent++)) # increase indent until this returns

    mkdir -p "$olint_cfg_dir" || {
        error_msg "Failed to create folder: $olint_cfg_dir"
    }
    olint_cfg_global="$olint_cfg_dir"/olint.conf

    if [[ -f "$olint_cfg_global" ]]; then
        #  handling base configuration
        source_file "$olint_cfg_global"
    else
        echo "Warning - no Global config file: $olint_cfg_global"
        echo
    fi

    declare -A override_linter_cmd # local array ie sans -g

    get_project_config
    de_duplicate_exclude_lists
    filter_hidden_vs_actually_excluded_patterns

    for linter_override in "${!override_linter_cmd[@]}"; do
        if [[ -z "${linter_cmd[$linter_override]}" ]]; then
            error_msg "Linter Not defined, can't be changed in $bname_proj_config: $linter_override " 2
        fi
        new_cmd="${override_linter_cmd[$linter_override]}"
        [[ -z "$new_cmd" ]] && {

            unset "linter_cmd[$linter_override]"
            #echo "lintercmd: ${!linter_cmd[*]}"
            continue
        }
        echo "Modifying linter: $linter_override"
        echo " replacing: ${linter_cmd[$linter_override]}"
        linter_cmd["$linter_override"]="${override_linter_cmd[$linter_override]}"
        echo "      with: ${linter_cmd[$linter_override]}"
    done
    unset override_linter_cmd

    # Remove dupes
    read -r -d '' -a skip_plugins <<<"$(remove_duplicates "${skip_plugins[@]}")"
    read -r -d '' -a prefixes <<<"$(remove_duplicates "${prefixes[@]}")"
    read -r -d '' -a suffixes <<<"$(remove_duplicates "${suffixes[@]}")"
}

display_config() {
    local linter_name
    local keys
    local ext
    local file_type
    local lst
    local item

    dbg_print "display_config()" "$dbglvl_lintscan_basic" 2

    echo "---  File-level Configuration  ---"
    if [[ -n "$olint_cfg_global" ]] || [[ -n "$olint_cfg_proj" ]]; then
        [[ -n "$olint_cfg_global" ]] && {
            if [[ -f "$olint_cfg_global" ]]; then
                echo "Global conf:  $olint_cfg_global"
            else
                echo "Global conf (not present):  $olint_cfg_global"
            fi
        }
        [[ -n "$olint_cfg_proj" ]] && echo "Project conf: $olint_cfg_proj"
        $use_cache && echo "Cache file:   $f_cache_file"
    else
        echo "Neither base nor project config found!"
    fi
    echo

    echo "---  Display configuration  ---"
    echo
    echo "State variables:"
    echo " verbosity_lvl:     $verbosity_lvl"
    echo " ignore_project:  $ignore_project"
    echo " mime_type_limit: $mime_type_limit"
    echo " lint_continue:   $lint_continue"
    echo " olint_plugin_dir:      $olint_plugin_dir"
    echo
    echo "Linters defined:"
    for linter_name in "${linter_order[@]}"; do
        echo " $linter_name  - ${linter_cmd[$linter_name]}"
    done
    echo

    echo "Supported File types: (lower cased for compatability)"
    for file_type in "${!linter_file_types[@]}"; do
        echo " '$file_type'  -  ${linter_file_types[$file_type]}"
    done
    echo
    $show_config_short && return

    echo "Supported extensions:"
    keys=$(for ext in "${!linter_extensions[@]}"; do echo "$ext"; done | sort)
    for ext in $keys; do
        echo " $ext  -  ${linter_extensions[$ext]}"
    done
    echo

    echo "Plugins skipped in $bname_proj_config:"
    lst="${skip_plugins[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Excluded patterns:"
    lst="${excluded_patterns[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Hidden Excludes:"
    lst="${hidden_patterns[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Excluded basenames file names (sans path):"
    lst="${excluded_basenames[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Excluded prefixes (sans path):"
    lst="${prefixes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Excluded suffixes:"
    lst="${suffixes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo

    echo "Excluded items:"
    lst="${excludes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo "  $item"
        done
    else
        echo "  None"
    fi
    echo
}

#---------------------------------------------------------------
#
#   Default settings
#
#---------------------------------------------------------------

initialize_env() {
    # dbg_print "initialize_env()" forced

    kernel_name="$(uname -s)"
    dbg_indent=1 # used to indent printouts in dbg_print
    bname_proj_config=".olint.conf"
    bname_cache=".cache.olint" # mtime|date|fname

    #  Define Global config location
    if [[ -n "$XDG_CONFIG_HOME" ]]; then
        olint_cfg_dir="$XDG_CONFIG_HOME"/olint
    else
        olint_cfg_dir=~/.config/olint
    fi

    defaults_for_cmdline
    defaults_for_config_file_excludes

    #  -----   linting env   -----

    files_without_matching_linter=0
    not_linting_msg="skipped task due to no-linters display beeing selected"

    f_linter_output=/"${TMPDIR:-tmp}"/olint["$$"]-linter-output

    declare -g -A linter_cmd
    declare -g -A linter_priorities
    declare -g -A linter_extensions
    declare -g -A linter_file_types
    linter_order=() # used to display them in alphabetical order

    #  -----   caching env   -----

    # Will only be updated if cache format is changed
    olint_cache_version="olint cache vers: 0.3.1"

    cache_is_changed=false
    declare -g -A cache_old     # What is read from cache file
    declare -g -A cache_new     # What will be written to cache file
    f_cache_file="$bname_cache" # initiaally assume its in same foleer

    #  -----   debug level helpers   -----

    #  Some debug level constants, to make it easier to limit what
    #  is displayed

    dbglvl_cache_events_basic=4
    dbglvl_cache_events_more="$((dbglvl_cache_events_basic + 1))"
    dbglvl_lintscan_basic=4
    dbglvl_lintscan_details="$((dbglvl_lintscan_basic + 1))"
    dbglvl_data_types=9
}

defaults_for_cmdline() {
    #  -----   defaults for cmdline options   -----

    show_config=false          # option: -c / -s
    lint_continue=false        # option: -C
    show_excluded=false        # option: -e / -E
    skip_common_excludes=false # extra setting for: -e / -E
    do_show_help=false         # option: -h
    mime_type_limit=false      # -m
    do_lint_files=true         # option: -n
    use_cache=true             # option: -N
    show_config_short=false    # option: -s
    verbosity_lvl=0            # option: -v
    h_max_age=0                # no max file age for items to be processed
}

defaults_for_config_file_excludes() {
    # ignore_project=yes   # Ignore this entire project from being processed.
    #                         Essentially prevent olint from running in this project
    #> use_cache=false      # Disable the use of cache for linting results.
    #> mime_type_limit=true # Only scan files based on their MIME type.
    #> lint_continue=true   # Continue linting even if errors are found.
    #> verbosity_lvl=9        # Set the verbosity of debug output.

    ignore_project=no

    olint_plugin_dir="$olint_cfg_dir"/plugins
    skip_plugins=() # plugins to skip in this project
    excluded_patterns=(
        __pycache__/
        .git/
        .mypy_cache/
        .pytest_cache/
        .venv/
        .vscode/
    )
    hidden_patterns=(
        __pycache__/
        .git/
        .mypy_cache/
        .pytest_cache/
        .venv/
        .vscode/
    )
    # basename excludes
    excluded_basenames=(
        "$bname_cache"
        .flake8
        .gitignore
        .shellcheckrc
    )
    # excludes by prefix
    prefixes=(
    )
    # excludes by suffix
    suffixes=(
        \~
        \#
        .pyc
    )
    #  Specifix excludes
    excludes=(
    )
}

#---------------------------------------------------------------
#
#   Data Types
#
#---------------------------------------------------------------

is_integer() {
    dbg_print "is_integer($1)" "$dbglvl_data_types"
    if [[ $1 =~ ^[0-9]+$ ]]; then
        return 0 # It's an integer
    else
        return 1 # It's not an integer
    fi
}

remove_duplicates() {
    local item
    local result

    result=("$@") # cant send $@ as a param
    dbg_print "remove_duplicates(${result[*]})" 3
    result=()
    for item in "$@"; do
        if [[ ! " ${result[*]} " =~ $item ]]; then
            result+=("$item")
        fi
    done
    echo "${result[@]}"
}

lowercase_it() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

#---------------------------------------------------------------
#
#   Cache handling
#
#---------------------------------------------------------------

cache_write() {
    #
    #  First line is expected to contain a cache version identifier,
    #  rest is: mtime|date|fname
    #
    local dbg_indent=$dbg_indent
    local key value

    $use_cache || {
        # abort if not using cache
        dbg_print "cache_write() - aborted due to not using cache" 1
        return
    }

    dbg_print "cache_write()" 3
    ((dbg_indent++)) # increase indent until this returns

    $do_lint_files || {
        dbg_print "$not_linting_msg" 3
        return
    }

    # If no changes have happened, no need to save cache
    $cache_is_changed || {
        dbg_print "skipped task due to no changes" 3
        return
    }

    # clear previous cache
    echo "$olint_cache_version" >"$f_cache_file"

    # Loop through the array and write all lines in one go
    for key in "${!cache_new[@]}"; do
        if [[ -v "cache_old[$key]" ]]; then
            # Remove the item if it is present
            unset "cache_old[$key]"
        fi

        value="${cache_new[$key]}"
        echo "$value|$key"
    done >>"$f_cache_file"

    # in case caching was aborted, keep unprocessed items in cache
    for key in "${!cache_old[@]}"; do
        value="${cache_old[$key]}"
        echo "$value|$key"
        dbg_print "kept in cache: $key" 1
    done >>"$f_cache_file"

    echo
    echo "${#cache_new[@]} successfully linted files cached in: $f_cache_file"
    [[ "$verbosity_lvl" -lt 1 ]] && echo "run with -v 1 to see cached files listed"
}

cache_read() {
    #
    #  First line is expected to contain a cache version identifier,
    #  rest is: mtime|date|fname
    #
    local dbg_indent=$dbg_indent
    local waiting_for_header=true
    local IFS
    local f_name
    local f_date
    local f_mtime

    $use_cache || {
        # abort if not using cache
        dbg_print "cache_read() - aborted due to not using cache" 1
        return
    }

    dbg_print "cache_read()" 2
    ((dbg_indent++)) # increase indent until this returns

    $do_lint_files || {
        dbg_print "$not_linting_msg" 2
        return
    }

    # Check if the file exists and is readable
    if [[ -r "$f_cache_file" ]]; then
        dbg_print "found cache file: $f_cache_file" 4

        # Read each line of the file and add to the array

        while IFS= read -r cached_line; do
            dbg_print "read line: $cached_line" 4
            if $waiting_for_header; then
                [[ "$cached_line" = "$olint_cache_version" ]] || {
                    echo
                    echo "Incorrect cache version"
                    echo "  expected: [$olint_cache_version]"
                    echo "  found:    [$cached_line]"
                    echo
                    echo "Will ignore this cache and replace it in 3 seconds - hit Ctrl-C to abort!"
                    sleep 3
                    break
                }
                waiting_for_header=false
                dbg_print "found correct header: $olint_cache_version" 4
                continue
            else
                IFS='|' read -r f_mtime f_date f_name <<<"$cached_line"
                cache_old["$f_name"]="$f_mtime|$f_date"
            fi
        done <"$f_cache_file"
    fi
}

get_cache_item() {
    #
    #  Returns true ands sets the following global variables
    #  if item matching f_to_check is present in the old cache
    #
    #   f_name
    #   f_mtime
    #   f_date
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent
    local cached_item

    dbg_print "get_cache_item($f_to_check)" "$dbglvl_cache_events_more" 2
    ((dbg_indent++)) # increase indent until this returns

    #
    #  [[ -v cache_old["$f_to_check"] ]] doesnt work on Debian 10
    #  instead first extract it to a variable, then do the check
    #
    cached_item="${cache_old["$f_to_check"]}"
    [[ -n "$cached_item" ]] || {
        dbg_print "item not found" "$((dbglvl_cache_events_more + 1))" 2
        return 1 # false
    }
    f_name="$f_to_check"
    IFS='|' read -r f_mtime f_date <<<"${cache_old[$f_name]}"
    return 0 # true
}

filename_is_cached() {
    #
    #  If file was in the old cache and is unchanged, this adds
    #  the entry to the new cache and returns True
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent

    $use_cache || return 1 # False

    dbg_print "filename_is_cached($f_to_check)" "$dbglvl_cache_events_more"
    ((dbg_indent++)) # increase indent until this returns

    #echo ">= filename_is_cached($1)"
    [[ -z "$f_to_check" ]] && error_msg "filename_is_cached() - called without param"

    #
    #  If f_to_check was present the following variables are set:
    #   f_name f_mtime f_date
    #
    get_cache_item "$f_to_check" || return 1 # False
    [[ "$(get_mtime "$f_name" || true)" -eq "$f_mtime" ]] && {
        cache_add "$f_name" "$f_mtime" "$f_date"
        return 0 # true
    }
    return 1 # False
}

cache_add() {
    #
    #  If available, iving f_mtime and f_date saves a recalculation
    #  and boosts performance.
    #
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local f_mtime="$2" # optional param
    local f_date="$3"  # optional param

    dbg_print "cache_add($f_name)" "$dbglvl_cache_events_basic"
    ((dbg_indent++)) # increase indent until this returns

    $use_cache || return
    [[ -z "$f_mtime" ]] && f_mtime="$(get_mtime "$f_name")"
    [[ -z "$f_date" ]] && f_date="$(mtime_2_date "$f_mtime")"

    cache_is_changed=true
    cache_new["$f_name"]="$f_mtime|$f_date"
    dbg_print "added $f_name = $f_mtime|$f_date" "dbglvl_cache_events_more"
}

#---------------------------------------------------------------
#
#   File Age related
#
#---------------------------------------------------------------

recent_enough() {
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local current_time
    local span_in_seconds

    dbg_print "recent_enough()" 9
    ((dbg_indent++)) # increase indent until this returns

    case "$h_max_age" in
    0) return 0 ;;  # Return right away if no max age is used
    -1) return 1 ;; # Always fail in -s mode
    *) ;;
    esac

    [[ "$h_max_age" = "0" ]] && return 0 # True - No time limit

    if [[ -z "$t_cutoff" ]]; then
        #
        #  For performance reasons only calculate once, and
        #  use a global var
        #
        current_time=$(date +%s) # Get current time in seconds since epoch
        span_in_seconds="$((3600 * h_max_age))"
        t_cutoff="$((current_time - span_in_seconds))"
    fi

    [[ "$(get_mtime "$f_name" || true)" -lt "$t_cutoff" ]] && {
        return 1 # False
    }
    return 0 # True
}

get_mtime() {
    local fname="$1"

    dbg_print "get_mtime($fname)" "$dbglvl_data_types"
    if [[ "$kernel_name" == "Darwin" ]]; then
        # macOS version
        stat -f "%m" "$fname"
    else
        # Linux version
        stat -c "%Y" "$fname"
    fi
}

mtime_2_date() {
    local f_mtime
    local as_date

    dbg_print "mtime_2_date($1)" "$dbglvl_data_types"
    if is_integer "$1"; then
        f_mtime="$1"
    else
        # Assume it is a file name
        f_mtime="$(get_mtime "$1"))"
    fi

    case "$kernel_name" in
    "Darwin") as_date="$(date -r "$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
    *) as_date="$(date -d "@$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
    esac

    dbg_print "result [$as_date]" "$((dbglvl_data_types + 1))"
    echo "$as_date"
}

#---------------------------------------------------------------
#
#   Linting setup
#
#---------------------------------------------------------------

check_linter_plugins() {
    local dbg_indent=$dbg_indent
    local plugin_dir="$1"
    local plugin_count=0
    local file_type

    if [[ -z "$plugin_dir" ]]; then
        error_msg "check_linter_plugins() - called with no plugin_dir param"
    elif [[ ! -d "$plugin_dir" ]]; then
        error_msg "Plugin folder missing: $plugin_dir"
    fi

    dbg_print "check_linter_plugins($plugin_dir)" 2
    ((dbg_indent++)) # increase indent until this returns

    # Loop through each file in alphabetical order
    for plugin_def in "$plugin_dir"/*; do
        [[ ! -f "$plugin_def" ]] && continue
        ((plugin_count += 1))

        # skip files ending with ~
        [[ "${plugin_def%"~"}" != "$plugin_def" ]] && continue
        # Process the file here
        parse_plugin_file "$plugin_def"
    done
    [[ "$plugin_count" -eq 0 ]] && {
        error_msg "No plugins found in: $plugin_dir"
    }
}

parse_plugin_file() {
    local plugin_def="$1"
    local dbg_indent=$dbg_indent
    local plugin_name
    local plugin_priority
    local plugin_cmd
    local item
    local plugin_cmd_actual
    local cmd_ok
    local plugin_extensions
    local plugin_file_types
    local ext
    local file_type

    dbg_print "parse_plugin_file($plugin_def)" "$dbglvl_lintscan_basic"
    ((dbg_indent++)) # increase indent until this returns

    plugin_name=$(basename "$plugin_def") # defaults to fname of plugin
    plugin_priority=10                    # set a default priority

    source_file "$plugin_def"

    [[ -z "$plugin_cmd" ]] && {
        dbg_print "Plugin $plugin_def - missing: plugin_cmd" 0
        return 1 # False
    }

    for item in "${skip_plugins[@]}"; do
        [[ "$item" = "$plugin_name" ]] && {
            dbg_print "$plugin_name was in skip_plugins item [$item]" \
                "$dbglvl_lintscan_details"
            return 1 # False
        }
    done

    if [[ -n "$plugin_cmd_actual" ]]; then
        check_cmd="$plugin_cmd_actual"
    else
        check_cmd="$plugin_cmd"
    fi

    cmd_ok="$(verify_lint_cmd "$check_cmd")"
    [[ -z "$cmd_ok" ]] && {
        # command not found - linter not installed/available
        return 1 # False
    }
    if [[ -n "$plugin_cmd_actual" ]]; then
        # use the intended cmd - potentially a function
        cmd_ok="$(verify_lint_cmd "$plugin_cmd")"
        [[ -z "$cmd_ok" ]] && {
            # command not found - linter not installed/available
            return 1 # False
        }
    fi

    linter_cmd["$plugin_name"]="$cmd_ok"
    linter_order+=("$plugin_name")

    linter_priorities["$plugin_name"]="$plugin_priority"

    [[ ${#plugin_extensions[@]} -eq 0 ]] &&
        [[ ${#plugin_file_types[@]} -eq 0 ]] && {

        error_msg "Plugin $plugin_def - neither plugin_extensions nor plugin_file_types defined"
    }

    for ext in "${plugin_extensions[@]}"; do
        add_plugin_extension "$plugin_name" "$plugin_priority" "$ext"
    done

    for file_type in "${plugin_file_types[@]}"; do
        add_plugin_file_type "$plugin_name" "$(lowercase_it "$file_type")"
    done
    return 0 # True
}

add_plugin_extension() {
    local dbg_indent=$dbg_indent
    local plugin="$1"
    local plugin_priority="$2"
    local ext="$3"
    local item
    local unsorted

    dbg_print "add_plugin_extension($plugin, $plugin_priority, $ext)" "$dbglvl_lintscan_basic"
    ((dbg_indent++)) # increase indent until this returns
    if [[ -z "${linter_extensions[$ext]}" ]]; then
        linter_extensions[$ext]="$plugin"
    else
        for item in ${linter_extensions[$ext]}; do
            [[ "$item" = "$plugin" ]] && return 0
        done
        linter_extensions[$ext]+=" $plugin"

        unsorted=()
        for itm in ${linter_extensions[$ext]}; do
            unsorted+=("$itm")
        done
        linter_extensions[$ext]="$(sort_linters unsorted)"
    fi
}

add_plugin_file_type() {
    local dbg_indent=$dbg_indent
    local plugin="$1"
    local file_type="$2"
    local item

    lc_file_type="${file_type,,}"
    dbg_print "add_plugin_file_type($plugin, $lc_file_type)" "$dbglvl_lintscan_basic"
    ((dbg_indent++)) # increase indent until this returns

    if [[ -z "${linter_file_types[$lc_file_type]}" ]]; then
        linter_file_types[$lc_file_type]="$plugin"
    else
        for item in ${linter_file_types[$lc_file_type]}; do
            [[ "$item" = "$plugin" ]] && return 0
        done
        linter_file_types[$lc_file_type]+=" $plugin"

        unsorted=()
        for itm in ${linter_file_types[$lc_file_type]}; do
            unsorted+=("$itm")
        done

        sorted_items="$(sort_linters unsorted)"
        linter_file_types[$lc_file_type]="$sorted_items"
    fi
    # #if [[ -z "${linter_file_types[$lc_file_type]}" ]]; then
    # if [[ ${#linter_file_types[@]} -eq 0 ]]; then
    #     dbg_print "><> addig first item [$lc_file_type] to linter_file_types"
    #     # linter_file_types["posix shell script"]="some_value"
    #     linter_file_types["$lc_file_type"]="hepp"
    #     linter_file_types["$lc_file_type"]="$plugin"
    #     error_msg "chk if it worked"
    # elif [[ -z "${linter_file_types[\"$lc_file_type\"]+isset}" ]]; then
    #     for item in ${linter_file_types[$lc_file_type]}; do
    #         [[ "$item" = "$plugin" ]] && return 0
    #     done
    #     linter_file_types[$lc_file_type]+=" $plugin"

    #     unsorted=()
    #     for itm in ${linter_file_types[$lc_file_type]}; do
    #         unsorted+=("$itm")
    #     done

    #     sorted_items="$(sort_linters unsorted)"
    #     linter_file_types[$lc_file_type]="$sorted_items"
    # else
    #     dbg_print "><> addig new item [$lc_file_type] to linter_file_types"
    #     linter_file_types[$lc_file_type]="$plugin"
    # fi
}

do_parse_linter_def() {
    #
    #  Handles the different notations
    #   linter_cmd
    #   linter_cmd -with -options
    #   ""
    #   prints the verified command if found or ""
    #
    local dbg_indent=$dbg_indent
    local lint_cmd="$1"
    local cmd
    local options
    local verif_cmd

    dbg_print "do_parse_linter_def($lint_cmd)" "$dbglvl_lintscan_details"
    ((dbg_indent++)) # increase indent until this returns
    if [[ -z "$lint_cmd" ]]; then
        cmd=""
        options=""
    elif [[ "${lint_cmd%"${lint_cmd#?}"}" = "-" ]]; then
        error_msg "linter cmd starts with  [$lint_cmd]" -1
        cmd=""
        options=""
    else
        cmd="$(echo "$lint_cmd" | cut -d' ' -f1)"
        options="$(echo "$lint_cmd" | cut -d' ' -f2-)"
    fi

    # if there were no options they will be the same
    [[ "$options" = "$cmd" ]] && options=""

    if [[ -n "$cmd" ]]; then
        verif_cmd="$(command -v "$cmd")" || {
            verif_cmd=""
        }
    else
        verif_cmd=""
    fi
    [[ -z "$verif_cmd" ]] && {
        cmd=""
        options=""
    }

    [[ -n "$verif_cmd" ]] && [[ -n "$options" ]] &&
        verif_cmd="$verif_cmd $options"
    echo "$verif_cmd"
    return 0 # True
}

verify_lint_cmd() {
    local dbg_indent=$dbg_indent
    local lint_cmd="$1"
    local cmd_parsed

    dbg_print "verify_lint_cmd($lint_cmd)" "$dbglvl_lintscan_details"
    ((dbg_indent++)) # increase indent until this returns

    if cmd_parsed="$(do_parse_linter_def "$lint_cmd")"; then
        echo "$cmd_parsed"
    else
        error_msg "Failed to parse lint cmd: $lint_cmd"
    fi
    # dbg_print "result [$cmd_parsed]" 2
}

sort_linters() {
    # Function to sort linters based on priorities
    local -n linters_array=$1
    local sorted_linters=()

    dbg_print "sort_linters(${linters_array[*]}" "$dbglvl_lintscan_details"

    if test -d /proc/ish; then
        #
        #  iSH kernel doesnt support enough of /proc to make mapfile work
        #
        # shellcheck disable=SC2207
        sorted_linters=($(
            for linter in "${linters_array[@]}"; do
                echo "$linter ${linter_priorities[$linter]}"
            done | sort -k2nr | awk '{print $1}'
        ))
    else
        mapfile -t sorted_linters < <(
            for linter in "${linters_array[@]}"; do
                echo "$linter ${linter_priorities[$linter]}"
            done | sort -k2nr | awk '{print $1}'
        )
    fi
    # dbg_print "sort_linters() - sorted [${sorted_linters[*]}]" 0
    echo "${sorted_linters[@]}"
}

#---------------------------------------------------------------
#
#   Linting actions
#
#---------------------------------------------------------------

handle_linting_error() {
    #
    #  Either write out allready processed files to cache and then exit
    #  or continue based upon
    #
    dbg_print "handle_linting_error()" 2
    $lint_continue && return
    env_cleanup 2
}

show_linter_action() {
    #
    #  Display what linter is used and what file is processed
    #
    local fname="$1"
    local linter="$2"

    # Print using printf with fixed-width formatting
    printf "%-14s: %s\\n" "$linter" "$fname"
}

lint_file() {
    local linter="$1"
    local fname="$2"

    dbg_print "lint_file($linter, $fname)" 4
    dbg_print " running: ${linter_cmd["$linter"]} $fname" 8
    #
    #  In order to avoid some linters untrapping Ctrl-C
    #  they are run in the background. Then some code to ensure the
    #  exit code of the linter is captured
    #
    eval "${linter_cmd["$linter"]}" "$fname" >"$f_linter_output" 2>&1 &
    lint_pid=$!
    wait "$lint_pid"
    lint_exit_status=$?

    if [[ "$lint_exit_status" -eq 0 ]]; then
        return 0 # True
    else
        cat "$f_linter_output"
        handle_linting_error
    fi
    return 1 # False
}

#---------------------------------------------------------------
#
#   Process files
#
#---------------------------------------------------------------

should_fname_be_excluded() {
    #
    #  Check if fname matches exclusion rules
    #
    local fname="$1"
    local item pattern rel_fname

    $skip_common_excludes && {
        for item in "${hidden_patterns[@]}"; do
            [[ $fname =~ $item ]] && return 0
        done
    }

    # Check if the filename matches any pattern
    for pattern in "${excluded_patterns[@]}"; do
        [[ "$fname" =~ $pattern ]] && {
            $show_excluded && show_linter_action "$fname" "patterns"
            return 0
        }
    done

    rel_fname="$(basename "$fname")"
    for item in "${excluded_basenames[@]}"; do
        [[ "$rel_fname" = "$item" ]] && {
            $show_excluded && show_linter_action "$fname" "rel fname"
            return 0
        }
    done

    for item in "${prefixes[@]}"; do
        [[ "$rel_fname" = "$item"* ]] && {
            $show_excluded && {
                show_linter_action "$fname" "prefix"
            }
            return 0 # True
        }
    done

    for item in "${suffixes[@]}"; do
        [[ "$rel_fname" = *"$item" ]] && {
            $show_excluded && show_linter_action "$fname" "suffix"
            return 0 # True
        }
    done

    for item in "${excludes[@]}"; do
        [[ "$fname" = "$item" ]] && {
            $show_excluded && show_linter_action "$fname" "excludes"
            return 0 # True
        }
    done

    return 1 # False
}

# shellcheck disable=SC2317
handle_ctrl_c() {
    trap '' INT # abort capturing Ctrl-C
    echo
    echo "Ctrl-C captured, terminating olint"
    echo
    echo "Saving allready checked files to cache"
    env_cleanup 1
}

lint_by_ext() {
    local dbg_indent=$dbg_indent
    local fname="$1"
    local extension
    local linter_found
    local linter_found_issue
    local linter

    dbg_print "lint_by_ext($fname)" 3
    ((dbg_indent++)) # increase indent until this returns

    extension="${fname##*.}"
    if [[ "$extension" != "$fname" ]]; then
        extension=".$extension"
    else
        return 1 # False - next linter
    fi
    case "$extension" in
    *"/"*) return 1 ;; # . was in part of path
    *) ;;
    esac

    linter_found=false
    [[ -n "$extension" ]] && {
        #
        #  Processing by extension
        #
        linter_found_issue=false
        for linter in ${linter_extensions[$extension]}; do
            [[ -z ${linter_cmd["$linter"]} ]] && {
                # linter has been disabled
                continue
            }
            linter_found=true
            $do_lint_files || {
                dbg_print "$not_linting_msg" 4
                return 0 # True - next file
            }
            show_linter_action "$fname" "$linter"
            lint_file "$linter" "$fname" || linter_found_issue=true
        done
        if $linter_found; then
            dbg_print "processed by ext handler - $fname" 3
            $linter_found_issue || {
                cache_add "$fname"
            }
            return 0 # True - next file
        fi
    }
    return 1 # False - next linter
}

lint_by_file_type() {
    local dbg_indent=$dbg_indent
    local fname="$1"
    local file_type="$2"
    local linter_found_issue
    local linter_found
    local lf_type
    local linter

    dbg_print "lint_by_file_type($file_type)" 3
    ((dbg_indent++)) # increase indent until this returns

    linter_found_issue=false
    linter_found=false
    for lf_type in "${!linter_file_types[@]}"; do
        # shellcheck disable=SC2053
        [[ "$file_type" == $lf_type ]] || {
            continue
        }
        # iterate over linters matching lf_type
        for linter in ${linter_file_types[$lf_type]}; do
            [[ -z ${linter_cmd["$linter"]} ]] && {
                # linter has been disabled
                continue
            }
            linter_found=true
            $do_lint_files || {
                dbg_print "$not_linting_msg" 4
                return 0 # True - next file
            }
            show_linter_action "$fname" "$linter"
            lint_file "$linter" "$fname" || linter_found_issue=true

            # not needed for visual inspection, but might be handy for
            # log analysis to get both lf_type and linter in one line
            dbg_print "processed as '$lf_type' - $linter" 9
        done
    done
    if $linter_found; then
        $linter_found_issue || {
            cache_add "$fname"
        }
        return 0 # True - next file
    fi
    dbg_print "Unsupported file_type - $file_type" 4
    return 1 # False - next file_type

}

generate_list_of_files_to_process() {
    #
    #  Sets all_files to be a reverse chronological order list
    #  of all files in the current file tree
    #
    dbg_print "generate_list_of_files_to_process()" 2

    printf "Generating sorted tree of all files..."

    if [[ $kernel_name == "Darwin" ]]; then
        # macOS version
        # shellcheck disable=SC2312
        # mapfile -t all_files < <(find . -type f -exec stat -f '%m %N' {} \; | sort -n -r -k1,1 | cut -d' ' -f2- | sed 's#^\./##')
        mapfile -t all_files < <(find . -type f -exec stat -f '%m %N' {} + | sort -n -r -k1,1 | cut -d' ' -f2- | sed 's#^\./##')
    else
        if test -d /proc/ish; then
            #
            #  iSH kernel doesnt support enough of /proc to make mapfile work
            #
            # shellcheck disable=SC2207
            #all_files=($(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2- | sed 's#^\./##'))
            all_files=($(find . -type f -printf '%T@ %P\n' | sort -n -r -k1,1 | cut -d' ' -f2-))
        else
            # mapfile -t all_files < <(find . -type f -printf '%T@ %p\n' | sort -n -r -k1,1 | cut -d' ' -f2- | sed 's#^\./##')
            mapfile -t all_files < <(find . -type f -printf '%T@ %P\n' | sort -n -r -k1,1 | cut -d' ' -f2-)
        fi
    fi
    echo "done!"
}

process_file_tree() {
    #
    #  Loop over al files, sorted by file age, newest firtst.
    #  Then identifying filetype using: file -b
    #  grouping by type, and linting files suitable for such
    #  as they come up. Thereby minimizing pointless wait time, since
    #  the file tree is globally sorted by age
    #
    local dbg_indent=$dbg_indent
    local all_files
    local fname
    local linter_found
    local file_types
    local file_type

    dbg_print "process_file_tree()" 2
    ((dbg_indent++)) # increase indent until this returns

    generate_list_of_files_to_process

    orig_dbg_indent=$dbg_indent
    trap 'handle_ctrl_c INT' INT
    for fname in "${all_files[@]}"; do
        dbg_indent=$orig_dbg_indent
        [[ -z "$fname" ]] && continue

        linter_found=false
        [[ -d "$fname" ]] && continue

        # [[ "$fname" = "files_to_check/base.py" ]] || continue
        should_fname_be_excluded "$fname" && continue
        $show_excluded && continue

        dbg_print "Examining file: $fname" 2
        ((dbg_indent++)) # increase indent until this returns

        # abort if a time limit was set
        recent_enough "$fname" || {
            dbg_print "too old to be processed" 4
            # maintain file in new cache
            $use_cache && filename_is_cached "$fname"
            continue
        }

        $use_cache && filename_is_cached "$fname" && {
            $do_lint_files && dbg_print "no changes: $fname" 1
            continue
        }

        #
        #  Processing by file type
        #
        if $mime_type_limit; then
            file_cmd="file --mime-type -b"
        else
            file_cmd="file -b"
        fi
        IFS='|' read -r -a file_types <<<"$($file_cmd "$fname" |
            tr '[:upper:]' '[:lower:]' | sed 's#, #|#g')"
        for file_type in "${file_types[@]}"; do
            lint_by_file_type "$fname" "$file_type" && {
                linter_found=true
                break
            }
        done
        $linter_found && continue

        #
        #  Processing by file extension
        #
        lint_by_ext "$fname" && {
            linter_found=true
            continue
        }

        $do_lint_files || {
            $linter_found || {
                ((files_without_matching_linter++))
                show_linter_action "$fname" "= No linter ="
            }
        }
    done
    trap '' INT # abort capturing Ctrl-C

    [[ $files_without_matching_linter -gt 0 ]] && {
        echo
        echo "Found $files_without_matching_linter files with no linter defined"
    }
}

display_hidden_excludes() {
    local item
    for item in "${hidden_patterns[@]}"; do
        echo "                      $item"
    done
}
show_help() {
    local prog_name

    prog_name=$(basename "$0")
    echo "Usage: $prog_name [-h] [-c] [-C] [--config-dir] [-n] [-N] [-v verbosity_lvl] [number]

Lint all files recursively in reverse chronological order.

Available options:

-h, --help          Print this help and exit
-c, --config        List supported and used linters and excluded file patterns
-C, --continue      Continue with the next file after linter issues are found
    --config-dir    Prints out where global config files are located
-e  --excluded      List all files that are excluded, except typically
                    uninteresting items, currently:
$(display_hidden_excludes)
-E  --excluded-all  Reallly list all files that are excluded
-m  --mime-type     When scaning files, only identify by mime-type
-n, --no-linter     Lists all files without a matching linter
-N, --nocache       Don't use caching for successfully linted files
-v, --verbose       Set verbosity level, level must also be suplied
-s, --conffig-short Only show config up to linters defined
-z, --zapcache      Remove cache file if present
number              Only check files changed in the last number hours

If a file is successfully linted, the filename and time of the latest change
are saved in a cache '$bname_cache'. Next time olint is run, files that have
not been changed are skipped.

If an '$bname_proj_config' is found, it is read after the global config file.
This can be used to define plugins, filenames, prefixes and suffixes
that should be excluded for this project.
See README.md for more information about this file.
"
    #endregion
}

#===============================================================
#
#   Main
#
#===============================================================

# echo "====  initial proc [$$]"

initialize_env
parse_cmd_line "$@"

#  Dependencies
[[ -z "$(command -v file)" ]] && error_msg "Missing dependency: file"

[[ "$verbosity_lvl" -gt 0 ]] && echo "Verbosity lvl is: $verbosity_lvl"

get_config

$do_show_help && {
    # In order to show list of hidden excludes, get_config must be called first
    show_help || error_msg "show_help() failure"
    env_cleanup 0
}

if [[ -d "$olint_plugin_dir" ]]; then
    check_linter_plugins "$olint_plugin_dir"
else
    msg="Without plugins olint will not be able to do any linting!\n"
    msg+="No plugin folder found: $olint_plugin_dir"
    error_msg "$msg"
fi

$show_config && {
    display_config
    env_cleanup 0
}

should_project_be_ignored

$lint_continue && echo "Will contine with next file if linter found issues"
$use_cache || {
    echo "Will not use cache for checked files"
    # [[ -f "$f_cache_file" ]] && {
    #     echo "Removing $f_cache_file"
    #     rm -f "$f_cache_file"
    # }
}
echo

cache_read ### R
process_file_tree
env_cleanup 0
