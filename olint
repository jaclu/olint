#!/usr/bin/env bash
#
#  Part of https://github.com/jaclu/olint
#
#  Copyright (c) 2024-2025: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  lists the entire file tree, then does a global
#  reverse sort, in order to process most recently
#  changed files first, disregarding what folder they are in.
#
#  For those file types that a linter is defined, linting is done
#  in the order the files are found. This means the last changed
#  file is the first to be checked.
#
#

# shellcheck disable=SC2317,SC2329
handle_ctrl_c() {
    trap '' INT # abort capturing Ctrl-C
    echo
    echo "Ctrl-C captured, terminating olint"
    echo
    echo "Saving already checked files to cache"
    env_cleanup 1
}

error_msg() {
    #
    #  Display error to /dev/stderr, and exit if exit code > -1
    #
    local msg="$1"
    local exit_code="${2:-1}"

    if [[ -z "$msg" ]]; then
        echo
        echo "error_msg() no param"
        env_cleanup 9
    fi
    # shellcheck disable=SC2059 # msg needs to be allowed to contain \n
    printf "\\n\\nERROR: $msg\\n\\n" >&2
    [[ "$exit_code" -gt -1 ]] && {
        if [[ "$3" = "no_cleanup" ]]; then
            exit "$exit_code"
        else
            env_cleanup "$exit_code"
        fi
    }
}

log_it() {
    #
    #  Displays info to /dev/stderr, if 2nd param is: forced
    #  This will always be printed, practical to use early on in the
    #  program before verbosity_lvl & dbg_indent has been defined
    #  For such line, comment them out if not desired
    #
    local msg="$1"
    local this_verbose_level="${2:-1}"

    [[ "$this_verbose_level" = "forced" ]] && {
        local this_verbose_level=0
        local verbosity_lvl=1
        local dbg_indent=1
    }
    [[ "$verbosity_lvl" -lt "$this_verbose_level" ]] && return
    printf '%s>%*s%s\n' "$this_verbose_level" "$dbg_indent" "" "$msg" >&2
}

#---------------------------------------------------------------
#
#   Data Type checks and manipulations
#
#---------------------------------------------------------------

is_integer() {
    log_it "is_integer($1)" "$dbglvl_data_types"
    if [[ $1 =~ ^[0-9]+$ ]]; then
        return 0
    else
        return 1
    fi
}

lowercase_it() {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

str_in_array() {
    local item="$1"             # The first argument is the search string
    shift                       # Shift to remove the first argument (the item)
    local array_to_check=("$@") # Capture the remaining arguments as the array
    local element

    for element in "${array_to_check[@]}"; do
        if [[ "$element" == "$item" ]]; then
            return 0 # Return 0 (true) if found
        fi
    done

    return 1 # Return 1 (false) if not found
}

# remove_duplicates_1() {
#     # Does not require associative arrays, which makes it compatible with older
#     # versions of bash (pre-4.0). Inefficient for large arrays.
#     local item
#     local result

#     result=("$@") # can't send $@ as a param
#     result=()
#     for item in "$@"; do
#         if [[ ! " ${result[*]} " =~ $item ]]; then
#             result+=("$item")
#         fi
#     done
#     echo "${result[@]}"
# }

remove_duplicates_2() {
    # More efficient because it uses an associative array (declare -A),
    # where lookups are constant time (O(1)).
    # Requires bash 4.0 or higher

    # Take the input array as a parameter
    local input_array=("$@")
    # Declare a new array to hold the unique values
    local unique_array=()
    local value

    # Declare a local associative array to store unique elements
    declare -A seen

    # Iterate over the input array
    for value in "${input_array[@]}"; do
        if [[ -z "${seen[$value]}" ]]; then
            # If the value hasn't been seen yet, add it to the unique_array
            unique_array+=("$value")
            # Mark the value as seen
            seen[$value]=1
        else
            log_it "filter_duplicates() - found duplicate: $value" >/dev/stderr
        fi
    done

    # Output the unique array
    echo "${unique_array[@]}"
}

# remove_duplicates_3() {
#     # Fully POSIX-compatible if you replace local -a with set to handle arrays.
#     # Slower than remove_duplicates_2 for large arrays due to linear search.
#     local item
#     local -a unique_array=()
#     for item in "$@"; do
#         if ! printf '%s\n' "${unique_array[@]}" | grep -qxF -- "$item"; then
#             unique_array+=("$item")
#         fi
#     done
#     echo "${unique_array[@]}"
# }

de_duplicate_config() {
    # Remove dupes

    read -r -d '' -a skip_linters <<<"$(
        remove_duplicates_2 "${skip_linters[@]}"
    )"
    read -r -d '' -a excludes <<<"$(remove_duplicates_2 "${excludes[@]}")"
    read -r -d '' -a excluded_prefixes <<<"$(
        remove_duplicates_2 "${excluded_prefixes[@]}"
    )"
    read -r -d '' -a hidden_patterns <<<"$(
        remove_duplicates_2 "${hidden_patterns[@]}"
    )"
    read -r -d '' -a excluded_suffixes <<<"$(
        remove_duplicates_2 "${excluded_suffixes[@]}"
    )"
    read -r -d '' -a excluded_basenames <<<"$(
        remove_duplicates_2 "${excluded_basenames[@]}"
    )"
    read -r -d '' -a excluded_basename_prefixes <<<"$(
        remove_duplicates_2 "${excluded_basename_prefixes[@]}"
    )"
}

toggle_bool() {
    declare -n ref=$1
    if [[ "$ref" == "true" ]]; then
        ref=false
    else
        ref=true
    fi
}

#---------------------------------------------------------------
#
#   File Age related
#
#---------------------------------------------------------------

recent_enough() {
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local current_time
    local span_in_seconds

    log_it "recent_enough()" 9
    ((dbg_indent++)) # increase indent until this returns

    case "$h_max_age" in
        0) return 0 ;;  # Return right away if no max age is used
        -1) return 1 ;; # Always fail in -s mode
        *) ;;
    esac

    if [[ -z "$t_cutoff" ]]; then
        #
        #  For performance reasons only calculate once, and
        #  use a global var
        #
        current_time=$(date +%s) # Get current time in seconds since epoch
        span_in_seconds="$((3600 * h_max_age))"
        t_cutoff="$((current_time - span_in_seconds))"
    fi

    [[ "$(get_mtime "$f_name" || true)" -lt "$t_cutoff" ]] && {
        return 1
    }
    return 0
}

get_mtime() {
    local fname="$1"

    log_it "get_mtime($fname)" "$dbglvl_data_types"
    if [[ "$kernel_name" == "Darwin" ]]; then
        # macOS version
        stat -f "%m" "$fname"
    else
        # Linux version
        stat -c "%Y" "$fname"
    fi
}

mtime_2_date() {
    local f_mtime
    local as_date

    log_it "mtime_2_date($1)" "$dbglvl_data_types"
    if is_integer "$1"; then
        f_mtime="$1"
    else
        # Assume it is a file name
        f_mtime="$(get_mtime "$1"))"
    fi

    case "$kernel_name" in
        "Darwin") as_date="$(date -r "$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
        *) as_date="$(date -d "@$f_mtime" +'%Y-%m-%d %H:%M:%S')" ;;
    esac

    log_it "result [$as_date]" "$((dbglvl_data_types + 1))"
    echo "$as_date"
}

#---------------------------------------------------------------
#
#   Cache handling
#
#---------------------------------------------------------------

cache_set_timer() {
    t_cache_age="$(date +%s)"
}

maybe_update_cache() {
    local t

    t=$(("$(date +%s)" - t_cache_age))
    [[ "$t" -ge "$t_cashe_interval" ]] && {
        cache_write
        printf '  %s - cache updated, files processed so far: %d\n' \
            "$(date +'%Y-%m-%d %H:%M:%S')" "${#cache_new[@]}"
        cache_set_timer
    }
}

cache_write() {
    #
    #  First line is expected to contain a cache version identifier,
    #  rest is: mtime|date|fname
    #
    local dbg_indent=$dbg_indent
    local key value

    $b_use_cache || {
        # abort if not using cache
        log_it "cache_write() - aborted due to not using cache" 1
        return
    }

    log_it "cache_write()" "$dbglvl_cache_events_basic"
    ((dbg_indent++)) # increase indent until this returns

    $b_lint_files || {
        log_it "$not_linting_msg" "$dbglvl_cache_events_basic"
        return
    }

    # If no changes have happened, no need to save cache
    $cache_is_changed || {
        log_it "skipped task due to no changes" "$dbglvl_cache_events_basic"
        return
    }

    # clear previous cache
    echo "$olint_cache_version|$proj_lint_tasks_completed" >"$f_cache_file"

    # Loop through the array and write all lines in one go
    for key in "${!cache_new[@]}"; do
        if [[ -v "cache_old[$key]" ]]; then
            # Remove the item if it is present
            unset "cache_old[$key]"
        fi

        value="${cache_new[$key]}"
        echo "$value|$key"
    done >>"$f_cache_file"

    # keep unprocessed items in cache
    for key in "${!cache_old[@]}"; do
        value="${cache_old[$key]}"
        echo "$value|$key"
        log_it "kept in cache: $key" "$dbglvl_no_changes"
    done >>"$f_cache_file"
}

cache_read() {
    #
    #  First line is expected to contain a cache version identifier,
    #  rest is: mtime|date|fname
    #
    local dbg_indent=$dbg_indent
    local waiting_for_header=true
    local IFS
    local f_mtime
    local f_date
    local f_name
    local msg
    local clear_cach_File=false
    local cache_version

    $b_use_cache || {
        # abort if not using cache
        log_it "cache_read() - aborted due to not using cache" 1
        return
    }

    log_it "cache_read()" "$dbglvl_major_tasks"
    ((dbg_indent++)) # increase indent until this returns

    $b_lint_files || {
        log_it "$not_linting_msg" "$dbglvl_major_tasks"
        return
    }

    [[ "$running_on_ish" -eq 1 ]] && ish_sysload_check

    # Check if the file exists and is readable
    if [[ -r "$f_cache_file" ]]; then
        log_it "found cache file: $f_cache_file" "$dbglvl_cache_events_basic"

        # Read each line of the file and add to the array

        while IFS= read -r cached_line; do
            log_it "read line: $cached_line" "$dbglvl_cache_events_basic"
            if $waiting_for_header; then
                cache_version="$(echo "$cached_line" | cut -d'|' -f1)"
                proj_lint_tasks_completed="$(echo "$cached_line" | cut -d'|' -f2)"

                [[ "$cache_version" = "$olint_cache_version" ]] || {
                    echo
                    echo "Incorrect cache version"
                    echo "  expected: [$olint_cache_version]"
                    echo "  found:    [$cache_version]"
                    echo
                    msg="Will ignore this cache and replace it in 3 seconds"
                    msg+=" - hit Ctrl-C to abort!"
                    echo "$msg"
                    sleep 3
                    clear_cach_File=true
                    break
                }
                waiting_for_header=false
                log_it "found correct header: $olint_cache_version" \
                    "$dbglvl_cache_events_basic"
                continue
            else
                IFS='|' read -r f_mtime f_date f_name <<<"$cached_line"
                cache_old["$f_name"]="$f_mtime|$f_date"
            fi
        done <"$f_cache_file"
        $clear_cach_File && rm -f "$f_cache_file"
    fi
}

get_cache_item() {
    #
    #  Returns true ands sets the following global variables
    #  if item matching f_to_check is present in the old cache
    #
    #   f_name
    #   f_mtime
    #   f_date
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent
    local cached_item

    log_it "get_cache_item($f_to_check)" "$dbglvl_cache_events_more"
    ((dbg_indent++)) # increase indent until this returns

    #
    #  [[ -v cache_old["$f_to_check"] ]] doesn't work on Debian 10
    #  instead first extract it to a variable, then do the check
    #
    cached_item="${cache_old["$f_to_check"]}"
    [[ -n "$cached_item" ]] || {
        log_it "item not found" "$((dbglvl_cache_events_more + 1))"
        return 1
    }
    f_name="$f_to_check"
    IFS='|' read -r f_mtime f_date <<<"${cache_old[$f_name]}"
    return 0
}

filename_is_cached() {
    #
    #  If file was in the old cache and is unchanged, this adds
    #  the entry to the new cache and returns True
    #
    local f_to_check="$1"
    local dbg_indent=$dbg_indent

    $b_use_cache || return 1

    log_it "filename_is_cached($f_to_check)" "$dbglvl_cache_events_more"
    ((dbg_indent++)) # increase indent until this returns

    [[ -z "$f_to_check" ]] && error_msg "filename_is_cached() - called without param"

    #
    #  If f_to_check was present the following variables are set:
    #   f_name f_mtime f_date
    #
    get_cache_item "$f_to_check" || return 1
    [[ "$(get_mtime "$f_name" || true)" -eq "$f_mtime" ]] && {
        cache_add "$f_name" "$f_mtime" "$f_date"
        return 0
    }
    return 1
}

cache_add() {
    #
    #  If available, iving f_mtime and f_date saves a recalculation
    #  and boosts performance.
    #
    local dbg_indent=$dbg_indent
    local f_name="$1"
    local f_mtime="$2" # optional param
    local f_date="$3"  # optional param

    log_it "cache_add($f_name)" "$dbglvl_cache_events_basic"
    ((dbg_indent++)) # increase indent until this returns

    $b_use_cache || return
    [[ -z "$f_mtime" ]] && f_mtime="$(get_mtime "$f_name")"
    [[ -z "$f_date" ]] && f_date="$(mtime_2_date "$f_mtime")"

    cache_is_changed=true
    cache_new["$f_name"]="$f_mtime|$f_date"
    log_it "added $f_name = $f_mtime|$f_date" "dbglvl_cache_events_more"
    maybe_update_cache
}

#---------------------------------------------------------------
#
#   Various displays
#
#---------------------------------------------------------------

show_help() {
    #region help text
    echo "
Usage: olint [-h] [-c] [-C] [-d] [-e] [-E] [-m] [-n] [-N] [-p] [-P] [-s] [-S]
                [-u time] [-v verbosity_lvl] [-z] [-Z] [number]

Lint all files recursively in reverse chronological order.

Available options:

-h, --help              Print this help and exit
-m, --mime-type         When scanning files, only identify by mime-type
-n, --no-linter         Lists all files without a matching linter
-p, --no-proj-lint      toggles 'Skip all project linters'
-P, --only-proj-lint    toggles 'Only run project linters'
-S, --statistics        Store linting times in SQL DB
-v, --verbose           Set verbosity level, level must also be supplied
                        1 - Show gathering of available plugins & nr of files linted
                        2 - List files already linted (cached)
                        Higher levels are mostly for debugging
-C, --continue          Continue with the next file after linter issues are found

--  Display configuration  --
-c, --config            List supported and used linters and excluded file patterns
-s, --conffig-short     Only show config up to linters defined
-e, --excluded          List all files that are excluded, except typically
                        uninteresting items, currently:
$(display_hidden_excludes)
-E, --excluded-all      Really list all files that are excluded
-d,  --config-dir        Prints out where global config files are located

--  Cache related  --
-N, --nocache           Don't use caching for successfully linted files
-u, --update-cache      How often cache should be saved (default: ${t_cashe_interval}s)
                        On all normal errors, cache will be saved on exit.
                        This is mostly useful when running in remote sessions.
                        To avoid a long running process lossing all progress due to
                        a lost connection.
-z, --zapcache          Remove cache file if present, then exit
-Z, --zaprun            First remove cache if present, then continue

number                  Only check files changed in the last number hours

If a file is successfully linted, the filename and time of the latest change
are saved in a cache '$bname_cache'. Next time olint is run, files that have
not been changed are skipped.

If an '$bname_proj_config' is found, it is read after the global config file.
This can be used to define plugins, filenames, prefixes and suffixes
that should be excluded for this project.
See README.md for more information about this file.
"
    #endregion
}

display_config() {
    local linter_name
    local keys
    local ext
    local file_type
    local lst
    local item

    log_it "display_config()" "$dbglvl_lintscan_basic"

    echo "=== Configuration   ==="
    echo

    if [[ -n "$olint_cfg_default" ]] || [[ -n "$olint_cfg_proj" ]]; then
        [[ -n "$olint_cfg_default" ]] && {
            if [[ -f "$olint_cfg_default" ]]; then
                echo "Global conf:  $olint_cfg_default"
            else
                echo "Global conf (not present):  $olint_cfg_default"
            fi
        }
        [[ -n "$olint_cfg_proj" ]] && echo "Project conf: $olint_cfg_proj"
        $b_use_cache && echo "Cache file:   $f_cache_file"
    else
        echo "Neither base nor project config found!"
    fi
    echo
    # echo "---  Display configuration  ---"
    # echo
    # echo "== State variables =="
    echo " verbosity_lvl:     $verbosity_lvl"
    echo " cache update:      $t_cashe_interval seconds"
    echo " ignore_project:    $ignore_project"
    echo " b_mime_type_limit:   $b_mime_type_limit"
    echo " b_lint_continue:     $b_lint_continue"
    echo " olint_plugin_dir:  $olint_plugin_dir"
    echo " b_proj_linters_skip: $b_proj_linters_skip"
    echo " b_proj_linters_only: $b_proj_linters_only"
    echo

    echo "==  Linters available  =="
    for linter_name in "${linter_order[@]}"; do
        echo " $linter_name  - ${linter_cmd[$linter_name]}"
    done
    echo

    [[ ${#proj_linters[@]} -gt 0 ]] && {
        echo "==  Linters handling the entire project  =="
        for linter_name in "${proj_linters[@]}"; do
            echo " $linter_name  - ${proj_linter_cmd[$linter_name]}"
        done
        echo
    }

    echo "==  Supported File types: (lower cased for compatibility)  =="
    for file_type in "${!linter_file_types[@]}"; do
        echo " '$file_type'  -  ${linter_file_types[$file_type]}"
    done
    echo
    $b_show_config_short && return

    echo "==  Supported extensions  =="
    keys=$(for ext in "${!linter_extensions[@]}"; do echo "$ext"; done | sort)
    for ext in $keys; do
        echo " $ext  -  ${linter_extensions[$ext]}"
    done
    echo

    echo "==  skip_linters - linter plugins excluded  =="
    lst="${skip_linters[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==   excluded_prefixes - anything starting with this will be excluded  =="
    lst="${excluded_prefixes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==  Hidden Excluded prefixes - will not be displayed when using -e  =="
    lst="${hidden_patterns[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==  excludes - full path to specific files to exclude  =="
    lst="${excludes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==  excluded_suffixes  =="
    lst="${excluded_suffixes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==  excluded_basenames - filename without the path  =="
    lst="${excluded_basenames[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo

    echo "==  excluded_basename_prefixes  =="
    lst="${excluded_basename_prefixes[*]}"
    if [[ -n "$lst" ]]; then
        for item in $lst; do
            echo " $item"
        done
    else
        echo " None"
    fi
    echo
}

display_hidden_excludes() {
    local item
    for item in "${hidden_patterns[@]}"; do
        echo "                          $item"
    done
}

display_time_elapsed() {
    local duration="$1"
    if ((duration > 59)); then
        #
        # Show long times in hh:mm:ss notation in order to make them stand out
        #
        local hours minutes seconds

        hours=$((duration / 3600))
        minutes=$(((duration % 3600) / 60))
        seconds=$((duration - hours * 3600 - minutes * 60))
        printf '%02d:%02d:%02d' "$hours" "$minutes" "$seconds"
    else
        printf '%ss' "$duration"
    fi
}

#---------------------------------------------------------------
#
#   Handle env
#
#---------------------------------------------------------------

initialize_env() {
    # log_it "initialize_env()" forced

    kernel_name="$(uname -s)"
    dbg_indent=1 # used to indent printouts in log_it

    # cache if this is running on iSH, since skipping a syscall on iSH makes a difference
    running_on_ish=0
    if [[ -d /proc/ish ]]; then
        running_on_ish=1
        ish_ift_uptime=/usr/local/bin/uptime
        [[ ! -x "$ish_ift_uptime" ]] && ish_ift_uptime=""
    fi

    # local folder for plugin overrides
    d_plugin_overrides="$(pwd)"/.olint_plugin_overrides

    # basenames, checked in multiple folders
    bname_proj_config=.olint.conf
    bname_cache=.cache.olint # mtime|date|fname

    #  Define Global config location
    # shellcheck disable=SC2154
    if [[ -n "$XDG_CONFIG_HOME" ]]; then
        olint_cfg_dir="$XDG_CONFIG_HOME"/olint
    else
        olint_cfg_dir=~/.config/olint
    fi
    olint_plugin_dir="$olint_cfg_dir"/plugins

    d_linting_venv=~/.config/olint/.venv
    b_olint_venv_enabled=false

    long_lint_time=5

    defaults_for_cmdline_options
    defaults_for_prog_config_file

    #  -----   sqlite3   -----

    f_sqlite_db="$HOME/tmp/foo/olint_stats.sqlite"
    f_sqlite_error="$HOME/tmp/foo/olint_stats.err"
    db_version=1
    b_log_sql=false

    #  -----   iSH specifics   -----

    ish_max_load=5
    ish_high_load_sleep=60

    #  -----   linting env   -----

    files_without_matching_linter=0
    not_linting_msg="skipped task due to no-linters display being selected"

    # used as a temp file during one linting cmd to capture output
    # to be displayed in case of issue
    f_linter_output=/"${TMPDIR:-tmp}"/olint["$$"]-linter-output

    declare -g -A linter_cmd
    declare -g -A proj_linter_cmd
    declare -g -A override_linter_cmd

    declare -g -A linter_priorities
    declare -g -A linter_extensions
    declare -g -A linter_file_types
    linter_order=() # used to display them in alphabetical order
    proj_linters=()

    #  -----   caching env   -----

    # Will only be updated if cache format is changed
    olint_cache_version="olint cache vers: 0.4.0"

    cache_is_changed=false
    declare -g -A cache_old     # What is read from cache file
    declare -g -A cache_new     # What will be written to cache file
    f_cache_file="$bname_cache" # initiaally assume its in same foleer

    # On slow system, log what proj linters have completed in the
    # cache file. This will be cleared once linting completes, so
    # on next run, all proj linters will be run
    proj_lint_tasks_completed=""

    #  -----   debug level helpers   -----

    #  Some debug level constants, to make it easier to limit what
    #  is displayed

    dbglvl_no_changes=2
    dbglvl_major_tasks=3
    dbglvl_cache_events_basic=6
    dbglvl_cache_events_more="$((dbglvl_cache_events_basic + 1))"
    dbglvl_lintscan_basic=6
    dbglvl_lintscan_details="$((dbglvl_lintscan_basic + 1))"
    dbglvl_lint_file_basic=7
    dbglvl_lint_file=8
    dbglvl_data_types=9
}

env_cleanup() {
    #
    #  Call this instead of exit, to ensure any cleanup will happen
    #    0 - no errors
    #    1 - did Ctrl-C
    #    2 - linting error
    #    9 - error_msg no param
    #
    #
    local duration
    local ex_code="${1:-1}"

    # when completed, clear this so that on next run all proj linters are run
    proj_lint_tasks_completed=""

    cache_write
    rm -f "$f_linter_output"

    olint_venv_disable

    [[ $ex_code -gt 1 ]] && {
        echo
        echo "*****  olint exited with an error  *****"
        echo
    }

    [[ -n "$t_app_start" ]] && $b_lint_files && {
        duration=$(($(date +%s) - t_app_start))
        if [[ "$verbosity_lvl" -ge 1 ]] || [[ "$duration" -ge "$long_lint_time" ]]; then
            # dont show time elapsed for very quick runs
            printf 'olint processing time: '
            display_time_elapsed "$duration"
            printf '\n'
            [[ "$verbosity_lvl" -ge 1 ]] && {
                echo
                echo "${#cache_new[@]} successfully linted files cached in: $f_cache_file"
                [[ "$verbosity_lvl" -lt 2 ]] && {
                    echo "run with -v 2 to see cached files listed"
                }
            }
        fi
    }
    exit "$ex_code"
}

defaults_for_cmdline_options() {
    #  -----   defaults for cmdline options   -----

    b_show_config=false          # options: -c / -s
    b_lint_continue=false        # option: -C
    b_show_excluded=false        # options: -e / -E
    b_skip_common_excludes=false # extra setting for: -e / -E
    b_show_help=false            # option: -h
    b_mime_type_limit=false      # option: -m
    b_lint_files=true            # option: -n
    b_use_cache=true             # option: -N
    b_proj_linters_skip=false    # option: -p
    b_proj_linters_only=false    # option: -P
    b_show_config_short=false    # option: -s
    b_use_statistics=false       # option: -S
    t_cashe_interval=60          # option: -u
    verbosity_lvl=0              # option: -v
    zap_it=0                     # options: -z / -Z
    h_max_age=0                  # no max file age for items to be processed
}

defaults_for_prog_config_file() {
    ignore_project=no

    skip_linters=() # plugins to skip in this project

    excluded_prefixes=( # start of fname
        __pycache__/
        .git/
        .mypy_cache/
        .pytest_cache/
        .ruff_cache/
        .venv/
        .vscode/
    )

    hidden_patterns=( # exclude from display of excluded_prefixes unless -E is used
        __pycache__/
        .git/
        .mypy_cache/
        .pytest_cache/
        .ruff_cache/
        .venv/
        .vscode/
    )
    excluded_suffixes=( # excludes by filename suffix
        \~
        \#
        .pyc
        .tmp
    )
    excludes=( # Specific excludes
    )
    excluded_basenames=( # basename (filename without any path) excludes
        "$bname_cache"
    )
    excluded_basename_prefixes=( # excludes by basename prefix
        \#
    )
    project_linters=(
        codespell # Normally always used as a project linter
    )
}

should_project_be_ignored() {
    #  Abort Check
    case "$(lowercase_it "$ignore_project")" in
        1 | "true" | "yes")
            echo "olint - Project ignored due to ignore_project=$ignore_project"
            echo "        Defined in: $olint_cfg_proj"
            env_cleanup 0
            ;;
        *) ;;
    esac
}

parse_cmd_line() {
    local cache_folders d_ceche_folder

    # log_it "parse_cmd_line()" forced
    while [[ -n "$1" ]]; do
        case $1 in
            -h | --help)
                #
                # only toggle a switch now, help will be displayed after
                # git_config is called
                #
                # shellcheck disable=SC2317
                b_show_help=true
                ;;
            -c | --config) b_show_config=true ;;
            -C | --continue) b_lint_continue=true ;;
            -d | --config-dir) # Support for ./deploy - prints out the config dir
                echo "$olint_cfg_dir"
                exit 0
                ;;
            -e | --excluded)
                b_show_excluded=true
                b_skip_common_excludes=true
                b_lint_files=false
                ;;
            -E | --excluded-all)
                b_show_excluded=true
                b_skip_common_excludes=false
                b_lint_files=false
                ;;
            -m | --mime-type) b_mime_type_limit=true ;;
            -n | --no-linter) b_lint_files=false ;;
            -N | --nocache) b_use_cache=false ;;
            -p | --no-proj-lint) toggle_bool b_proj_linters_skip ;;
            -P | --only-proj-lint) toggle_bool b_proj_linters_only ;;
            -s | --conffig-short)
                b_show_config=true
                b_show_config_short=true
                ;;
            -S | --statistics)
                b_use_statistics=true
                ;;
            -u | --update-cache)
                t="${2:-missing param}"
                [[ "$t" = "missing param" ]] && {
                    error_msg "-u/--update-cache without time param"
                }
                is_integer "$t" || error_msg "-u/--update-cache is no int: [$t]"
                t_cashe_interval="$t"
                shift # pop update interval
                ;;
            -v | --verbose)
                lvl="${2:-missing param}"
                [[ "$lvl" = "missing param" ]] && {
                    error_msg "-v/--verbose without verbosity lvl param"
                }
                is_integer "$lvl" || error_msg "verbosity_lvl is not int: [$lvl]"
                verbosity_lvl="$lvl"
                shift # pop debug level
                ;;
            -z | --zapcache)
                zap_it=1 # zap then exit
                ;;
            -Z | --zaprun)
                zap_it=2 # zap then run
                ;;
            *[!0-9]*) error_msg "Unrecognized option: $1" ;;

            *) # only remaining param type is an int
                h_max_age="$1"
                is_integer "$h_max_age" || error_msg "Max age is not int: $h_max_age"
                echo "Will only check files changed in the last $h_max_age hours"
                ;;

        esac
        shift
    done
    $b_proj_linters_skip && $b_proj_linters_only && {
        error_msg "-p & -P are both true - invalid state."
    }
}

olint_venv_enable() {
    # shellcheck disable=SC2154
    if [[ -d "$d_linting_venv" ]]; then
        if [[ $(command -v python3) == "$d_linting_venv/"* ]]; then
            echo "---  Already using olint venv  ---"
            return
        fi
        # [[ "$VIRTUAL_ENV_PROMPT" != "(linters) " ]]; then
        echo "===  Activating olint venv  ===" >/dev/stderr
        # shellcheck source=/dev/null
        . "$d_linting_venv/bin/activate" || {
            error_msg "Failed to activate linting venv"
        }
        b_olint_venv_enabled=true
    fi
}

olint_venv_disable() {
    $b_olint_venv_enabled && {
        echo "===  de-activating olint venv  ===" >/dev/stderr
        deactivate || error_msg "Failed to deactivate alpine linting venv"
    }
    return 0
}

#---------------------------------------------------------------
#
#   Read configs
#
#---------------------------------------------------------------

get_config() {
    local param_1="$1"
    local dbg_indent=$dbg_indent

    log_it "get_config()" "$dbglvl_major_tasks"
    ((dbg_indent++)) # increase indent until this returns

    mkdir -p "$olint_cfg_dir" || {
        # Ensure default config folder exists
        error_msg "Failed to create folder: $olint_cfg_dir"
    }
    olint_cfg_default="$olint_cfg_dir"/olint.conf

    if [[ -f "$olint_cfg_default" ]]; then
        #  handling base configuration
        read_config_file "$olint_cfg_default"
    else
        [[ "$param_1" != "--config-dir" ]] && {
            # Condition allows for displayal of default config location if
            # the base config file has not yet been installed
            echo "WARNING: Global config file not found: $olint_cfg_default"
            echo "WARNING: Using app defaults"
            echo
        }
    fi
    get_proj_config_recursive
    de_duplicate_config
    filter_hidden_vs_actually_excluded_patterns
}

source_file() {
    #  Source a file, exit with error on failure
    local f_name="$1"
    local dbg_indent=$dbg_indent

    log_it "source_file($f_name)" "$dbglvl_lintscan_details"
    # only indent if func name is displayed
    [[ "$verbosity_lvl" -gt 2 ]] && ((dbg_indent++))

    if [[ -f "$f_name" ]]; then
        # shellcheck source=/dev/null
        source "$f_name" || error_msg "Failed to source: $f_name"
        log_it "Sourced: $f_name" "$dbglvl_lintscan_details"
        return 0
    else
        log_it "source_file() - File not found: $f_name" 1
    fi
    return 1
}

read_config_file() {
    local f_config="$1"
    local found_issue=false
    local msg

    log_it "read_config_file($f_config)" "$dbglvl_major_tasks"

    source_file "$f_config" || {
        error_msg "Failed to source config file: $f_config"
    }

    #
    #  Scan for obsolete variables
    #
    # shellcheck disable=SC2154
    declare -p plugin_dir &>/dev/null && {
        msg+="\n  plugin_dir   ->   olint_plugin_dir"
        found_issue=true
    }
    # shellcheck disable=SC2154
    declare -p skip_plugins &>/dev/null && {
        msg+="\n  skip_plugins  ->  skip_linters"
        found_issue=true
    }
    # shellcheck disable=SC2154
    declare -p excluded_patterns &>/dev/null && {
        msg+="\n  excluded_patterns  ->  excluded_prefixes"
        found_issue=true
    }
    # shellcheck disable=SC2154
    declare -p suffixes &>/dev/null && {
        msg+="\n  suffixes  ->  excluded_suffixes"
        found_issue=true
    }
    # shellcheck disable=SC2154
    declare -p prefixes &>/dev/null && {
        msg+="\n  prefixes  ->  excluded_basename_prefixes"
        found_issue=true
    }
    $found_issue && {
        echo "ERROR: Obsolete config variables found in: $f_config"
        echo "       use the provided replacements"
        # shellcheck disable=SC2059
        printf "$msg\n"
        exit 1
    }
}

get_proj_config_recursive() {
    local dbg_indent=$dbg_indent

    log_it "get_proj_config_recursive()" "$dbglvl_major_tasks"
    ((dbg_indent++)) # increase indent until this returns

    # Traverse up until a project conf is found
    olint_cfg_proj=""
    dir=$(pwd)

    # Traverse up the directory tree
    while [[ "$dir" != "/" ]]; do
        olint_cfg_proj="$dir"/"$bname_proj_config"
        log_it "Checking for config in: $dir" "$dbglvl_major_tasks"
        if [[ -f "$olint_cfg_proj" ]]; then
            cd "$dir" || {
                error_msg "get_proj_config_recursive() failed to cd into: $dir"
            }
            read_config_file "$olint_cfg_proj"
            log_it "Using Project file: $olint_cfg_proj" "$dbglvl_major_tasks"
            f_cache_file="$dir/$bname_cache"
            log_it "Will use cache file: $f_cache_file" "$dbglvl_major_tasks"
            return
        fi
        dir=$(dirname "$dir")
    done
    olint_cfg_proj=""
    log_it "get_proj_config_recursive() - No Project config (.olint_conf) found!" 1
}

filter_hidden_vs_actually_excluded_patterns() {
    local tmp_hidden lst_h item_h lst_e item_e

    [[ ${#hidden_patterns[@]} -eq 0 ]] || [[ ${#excluded_prefixes[@]} -eq 0 ]] && {
        return # Either list was empty
    }

    tmp_hidden=("${hidden_patterns[@]}")
    hidden_patterns=()
    lst_h="${tmp_hidden[*]}"
    for item_h in $lst_h; do
        lst_e="${excluded_prefixes[*]}"
        for item_e in $lst_e; do
            if [[ "$item_h" = "$item_e" ]]; then
                hidden_patterns+=("$item_h")
                break
            fi
        done
    done
}

#---------------------------------------------------------------
#
#   Linting setup
#
#---------------------------------------------------------------

override_cmd() {
    local linter_override="$1"
    local cmd_ok="$2"

    linter_cmd["$linter_override"]="$cmd_ok"
}

override_proj_cmd() {
    local linter_override="$1"
    local cmd_ok="$2"

    proj_linter_cmd["$linter_override"]="$cmd_ok"
}

process_linter_overrides() {
    local linter_override
    local new_cmd
    local cmd_ok

    log_it "process_linter_overrides()" "$dbglvl_major_tasks"
    for linter_override in "${!override_linter_cmd[@]}"; do
        if ! str_in_array "$linter_override" "${linter_order[@]}" \
            && ! str_in_array "$linter_override" "${proj_linters[@]}"; then

            # linter not used, ignore override
            continue
        fi
        new_cmd="${override_linter_cmd[$linter_override]}"
        log_it "linter: $linter_override  - override command: $new_cmd" \
            "$((dbglvl_lintscan_basic + 1))"
        [[ -z "$new_cmd" ]] && {
            error_msg "override_linter_cmd[$linter_override]= - command not defined"
        }
        cmd_ok="$(verify_lint_cmd "$new_cmd")"
        [[ -z "$cmd_ok" ]] && {
            error_msg "override_linter_cmd[$linter_override]=$new_cmd - command not found"
        }
        if str_in_array "$linter_override" "${linter_order[@]}"; then
            override_cmd "$linter_override" "$cmd_ok"
        elif str_in_array "$linter_override" "${proj_linters[@]}"; then
            override_proj_cmd "$linter_override" "$cmd_ok"
        fi
    done
    # echo "process_linter_overrides() - done"
}

check_linter_plugins() {
    local dbg_indent=$dbg_indent
    local d_plugins="$1"
    local plugin_count=0
    local file_type
    local unsorted
    local sorted_items

    [[ "$verbosity_lvl" -ge 1 ]] && printf 'Gathering available linters: '
    if [[ -z "$d_plugins" ]]; then
        error_msg "check_linter_plugins() - called with no param"
    elif [[ ! -d "$d_plugins" ]]; then
        error_msg "Plugin folder missing: $d_plugins"
    fi

    log_it "check_linter_plugins($d_plugins)" "$dbglvl_major_tasks"
    ((dbg_indent++)) # increase indent until this returns

    # Loop through each file in alphabetical order
    for plugin_def in "$d_plugins"/*; do
        [[ ! -f "$plugin_def" ]] && continue
        # skip files ending with ~
        [[ "${plugin_def%"~"}" != "$plugin_def" ]] && continue

        ((plugin_count += 1))
        [[ -z "$plugin_def" ]] && {
            error_msg "check_linter_plugins() - found an empty \$plugin_def"
        }
        _p="$(basename "$plugin_def")"
        f_plugin_override="$d_plugin_overrides/$_p"
        if [[ -f "$f_plugin_override" ]]; then
            log_it "using plugin_override: $f_plugin_override" 1
            parse_plugin_file "$f_plugin_override" && [[ "$verbosity_lvl" -ge 1 ]] && {
                printf '+'
            }
        else
            parse_plugin_file "$plugin_def" && [[ "$verbosity_lvl" -ge 1 ]] && printf '.'
        fi
    done
    [[ "$plugin_count" -eq 0 ]] && {
        error_msg "No plugins found in: $d_plugins"
    }
    process_linter_overrides

    # Sort project linters
    unsorted=()
    for itm in "${proj_linters[@]}"; do
        unsorted+=("$itm")
    done
    sorted_items="$(sort_linters unsorted)"
    # shellcheck disable=SC2206 # in this case the string should be split
    proj_linters=($sorted_items)

    [[ "$verbosity_lvl" -ge 1 ]] && echo " done!"
}

parse_plugin_file() {
    local plugin_def="$1"
    local dbg_indent=$dbg_indent
    local plugin_name
    local proj_plugin_cmd
    local plugin_priority=50 # set a default priority
    local plugin_cmd
    local cmd_ok plugin_cmd_actual
    local item
    local plugin_extensions
    local plugin_file_types
    local ext
    local file_type
    local msg

    log_it "parse_plugin_file($plugin_def)" "$((dbglvl_lintscan_basic + 1))"
    ((dbg_indent++)) # increase indent until this returns

    [[ -z "$plugin_def" ]] && {
        error_msg "parse_plugin_file() - found an empty \$plugin_def"
    }
    plugin_name=$(basename "$plugin_def") # defaults to fname of plugin

    source_file "$plugin_def"

    if [[ -z "$proj_plugin_cmd" ]]; then
        [[ -z "$plugin_cmd" ]] && {
            log_it "Plugin $plugin_def - need either plugin_cmd or proj_plugin_cmd" 0
            return 1
        }
    fi

    for item in "${skip_linters[@]}"; do
        [[ "$item" = "$plugin_name" ]] && {
            log_it "$plugin_name was in skip_linters item [$item]" \
                "$dbglvl_lintscan_details"
            return 1
        }
    done

    # Save priorities before figuring out if it is a project or file linter
    linter_priorities["$plugin_name"]="$plugin_priority"

    if [[ " ${project_linters[*]} " == *" $plugin_name "* ]]; then
        [[ -z "$proj_plugin_cmd" ]] && {
            _m="$plugin_name listed as project_linter, but no proj_plugin_cmd defined"
            error_msg "$_m"
        }
        cmd_ok="$(verify_lint_cmd "$proj_plugin_cmd")"
        [[ -n "$cmd_ok" ]] && {
            # Handle it as a project spanning linter
            proj_linter_cmd["$plugin_name"]="$cmd_ok"
            proj_linters+=("$plugin_name")
            return 0
        }
        return 1
    fi

    #
    #  Handle it as a normal lint command
    #

    if [[ -n "$plugin_cmd_actual" ]]; then
        check_cmd="$plugin_cmd_actual"
    else
        check_cmd="$plugin_cmd"
    fi

    cmd_ok="$(verify_lint_cmd "$check_cmd")"
    [[ -z "$cmd_ok" ]] && {
        # command not found - linter not installed/available
        return 1
    }
    if [[ -n "$plugin_cmd_actual" ]]; then
        # use the intended cmd - potentially a function
        cmd_ok="$(verify_lint_cmd "$plugin_cmd")"
        [[ -z "$cmd_ok" ]] && {
            # command not found - linter not installed/available
            return 1
        }
    fi

    linter_cmd["$plugin_name"]="$cmd_ok"
    linter_order+=("$plugin_name")

    [[ ${#plugin_extensions[@]} -eq 0 ]] \
        && [[ ${#plugin_file_types[@]} -eq 0 ]] && {

        msg="Plugin $plugin_def - neither plugin_extensions"
        msg+=" nor plugin_file_types defined"
        error_msg "$msg"
    }

    for ext in "${plugin_extensions[@]}"; do
        add_plugin_extension "$plugin_name" "$plugin_priority" "$ext"
    done

    for file_type in "${plugin_file_types[@]}"; do
        add_plugin_file_type "$plugin_name" "$(lowercase_it "$file_type")"
    done
    return 0
}

add_plugin_extension() {
    local dbg_indent=$dbg_indent
    local plugin="$1"
    local plugin_priority="$2"
    local ext="$3"
    local item
    local unsorted

    log_it "add_plugin_extension($plugin, $plugin_priority, $ext)" \
        "$((dbglvl_lintscan_basic + 2))"
    ((dbg_indent++)) # increase indent until this returns
    if [[ -z "${linter_extensions[$ext]}" ]]; then
        linter_extensions[$ext]="$plugin"
    else
        for item in ${linter_extensions[$ext]}; do
            [[ "$item" = "$plugin" ]] && return 0
        done
        linter_extensions[$ext]+=" $plugin"

        unsorted=()
        for itm in ${linter_extensions[$ext]}; do
            unsorted+=("$itm")
        done
        linter_extensions[$ext]="$(sort_linters unsorted)"
    fi
}

add_plugin_file_type() {
    local dbg_indent=$dbg_indent
    local plugin="$1"
    local file_type="$2"
    local item

    lc_file_type="${file_type,,}"
    log_it "add_plugin_file_type($plugin, $lc_file_type)" \
        "$((dbglvl_lintscan_basic + 1))"
    ((dbg_indent++)) # increase indent until this returns

    if [[ -z "${linter_file_types[$lc_file_type]}" ]]; then
        linter_file_types[$lc_file_type]="$plugin"
    else
        for item in ${linter_file_types[$lc_file_type]}; do
            [[ "$item" = "$plugin" ]] && return 0
        done
        linter_file_types[$lc_file_type]+=" $plugin"

        unsorted=()
        for itm in ${linter_file_types[$lc_file_type]}; do
            unsorted+=("$itm")
        done

        sorted_items="$(sort_linters unsorted)"
        linter_file_types[$lc_file_type]="$sorted_items"
    fi
}

do_parse_linter_def() {
    #
    #  Handles the different notations
    #   linter_cmd
    #   linter_cmd -with -options
    #   ""
    #   prints the verified command if found or ""
    #
    local dbg_indent=$dbg_indent
    local lint_cmd="$1"
    local cmd
    local options
    local verif_cmd

    log_it "do_parse_linter_def($lint_cmd)" "$dbglvl_lintscan_details"
    ((dbg_indent++)) # increase indent until this returns
    if [[ -z "$lint_cmd" ]]; then
        cmd=""
        options=""
    elif [[ "${lint_cmd%"${lint_cmd#?}"}" = "-" ]]; then
        error_msg "linter cmd starts with  [$lint_cmd]" -1
        cmd=""
        options=""
    else
        cmd="$(echo "$lint_cmd" | cut -d' ' -f1)"
        options="$(echo "$lint_cmd" | cut -d' ' -f2-)"
    fi

    # if there were no options they will be the same
    [[ "$options" = "$cmd" ]] && options=""

    if [[ -n "$cmd" ]]; then
        verif_cmd="$(command -v "$cmd")" || {
            verif_cmd=""
        }
    else
        verif_cmd=""
    fi
    [[ -z "$verif_cmd" ]] && {
        cmd=""
        options=""
    }

    [[ -n "$verif_cmd" ]] && [[ -n "$options" ]] \
        && verif_cmd="$verif_cmd $options"
    echo "$verif_cmd"
    return 0
}

verify_lint_cmd() {
    local dbg_indent=$dbg_indent
    local lint_cmd="$1"
    local cmd_parsed

    log_it "verify_lint_cmd($lint_cmd)" "$dbglvl_lintscan_details"
    ((dbg_indent++)) # increase indent until this returns

    if cmd_parsed="$(do_parse_linter_def "$lint_cmd")"; then
        echo "$cmd_parsed"
    else
        error_msg "Failed to parse lint cmd: $lint_cmd"
    fi
    # log_it "result [$cmd_parsed]" "$dbglvl_lintscan_details"
}

sort_linters() {
    # Function to sort linters based on priorities
    local -n linters_array=$1
    local sorted_linters=()

    log_it "sort_linters(${linters_array[*]})" "$dbglvl_lintscan_details"

    if [[ "$running_on_ish" -eq 1 ]]; then
        #
        #  iSH kernel doesn't support enough of /proc to make mapfile work
        #
        # shellcheck disable=SC2207
        sorted_linters=($(
            for linter in "${linters_array[@]}"; do
                echo "$linter ${linter_priorities[$linter]}"
            done | sort -k2nr | awk '{print $1}'
        ))
    else
        mapfile -t sorted_linters < <(
            for linter in "${linters_array[@]}"; do
                echo "$linter ${linter_priorities[$linter]}"
            done | sort -k2nr | awk '{print $1}'
        )
    fi
    # log_it "sort_linters() - sorted [${sorted_linters[*]}]" 0
    echo "${sorted_linters[@]}"
}

#---------------------------------------------------------------
#
#   Linting actions
#
#---------------------------------------------------------------

lint_file() {
    local linter="$1"
    local fname="$2"
    local lint_pid
    local lint_exit_status

    log_it "lint_file($linter, $fname)" "$dbglvl_lint_file_basic"
    log_it " running: ${linter_cmd["$linter"]} $fname" "$dbglvl_lint_file"

    #
    #  In order to avoid some linters untrapping Ctrl-C
    #  they are run in the background. Then some code to ensure the
    #  exit code of the linter is captured
    #
    eval "${linter_cmd["$linter"]}" "$fname" >"$f_linter_output" 2>&1 &
    lint_pid=$!
    wait "$lint_pid"
    lint_exit_status=$?

    if [[ "$lint_exit_status" -eq 0 ]]; then
        return 0
    else
        printf '\n\n' # start error display on new line
        if [[ "$(wc -l <"$f_linter_output")" -gt 30 ]]; then
            #
            # prepending output with linter and file name, since when
            # displaying output in fullecreen the previous lines indicating
            # those details are not visible
            #
            printf '0a\nLinting command:\n%s\nFile: %s\n\n.\nw\n' \
                "${linter_cmd["$linter"]}" "$fname" | ed -s "$f_linter_output"
            less -R "$f_linter_output"
        else
            cat "$f_linter_output"
        fi
        handle_linting_error
    fi
    return 1
}

lint_by_ext() {
    local dbg_indent=$dbg_indent
    local fname="$1"
    local extension
    local b_linter_found
    local linter_found_issue
    local linter

    log_it "lint_by_ext($fname)" "$dbglvl_lintscan_details"
    ((dbg_indent++)) # increase indent until this returns

    extension="${fname##*.}"
    if [[ "$extension" != "$fname" ]]; then
        extension=".$extension"
    else
        return 1 # False - next linter
    fi
    case "$extension" in
        *"/"*) return 1 ;; # . was in part of path
        *) ;;
    esac

    b_linter_found=false
    [[ -n "$extension" ]] && {
        #
        #  Processing by extension
        #
        linter_found_issue=false
        for linter in ${linter_extensions[$extension]}; do
            [[ -z ${linter_cmd["$linter"]} ]] && {
                # linter has been disabled
                continue
            }
            b_linter_found=true
            $b_lint_files || {
                log_it "$not_linting_msg" "$dbglvl_lint_file_basic"
                return 0 # True - next file
            }
            show_linter_action "$linter" "$fname"
            lint_file "$linter" "$fname" || linter_found_issue=true
            show_linter_time
        done
        if $b_linter_found; then
            log_it "processed by ext handler - $fname" "$dbglvl_lintscan_details"
            $linter_found_issue || {
                cache_add "$fname"
            }
            return 0 # True - next file
        fi
    }
    return 1 # False - next linter
}

lint_by_file_type() {
    local dbg_indent=$dbg_indent
    local file_type="$1"
    local fname="$2"
    local linter_found_issue
    local b_linter_found
    local lf_type
    local linter

    log_it "lint_by_file_type($file_type, $fname)" "$dbglvl_lintscan_basic"
    ((dbg_indent++)) # increase indent until this returns

    linter_found_issue=false
    b_linter_found=false
    for lf_type in "${!linter_file_types[@]}"; do
        # shellcheck disable=SC2053
        [[ "$file_type" == $lf_type ]] || {
            continue
        }
        # iterate over linters matching lf_type
        for linter in ${linter_file_types[$lf_type]}; do
            [[ -z ${linter_cmd["$linter"]} ]] && {
                # linter has been disabled
                continue
            }
            b_linter_found=true
            $b_lint_files || {
                log_it "$not_linting_msg" "$dbglvl_lint_file_basic"
                return 0 # True - next file
            }
            show_linter_action "$linter" "$fname"
            lint_file "$linter" "$fname" || linter_found_issue=true
            show_linter_time

            # not needed for visual inspection, but might be handy for
            # log analysis to get both lf_type and linter in one line
            log_it "processed as '$lf_type' - $linter" 9
        done
    done
    if $b_linter_found; then
        $linter_found_issue || {
            cache_add "$fname"
        }
        return 0 # True - next file
    fi
    log_it "Unsupported file_type - $file_type" "$dbglvl_lint_file_basic"
    return 1 # False - next file_type

}

lint_proj() {
    local linter="$1"
    local lint_pid
    local lint_exit_status

    log_it "lint_proj($linter)" "$dbglvl_lint_file_basic"
    log_it " running: ${linter_cmd["$linter"]}" "$dbglvl_lint_file"

    show_linter_action "$linter_name" "=====  entire project  ====="
    #
    #  In order to avoid some linters untrapping Ctrl-C
    #  they are run in the background. Then some code to ensure the
    #  exit code of the linter is captured
    #
    eval "${proj_linter_cmd["$linter"]}" >"$f_linter_output" 2>&1 &
    lint_pid=$!
    wait "$lint_pid"
    lint_exit_status=$?
    show_linter_time "proj"

    if [[ "$lint_exit_status" -eq 0 ]]; then
        proj_lint_tasks_completed+=" $linter"
        return 0
    else
        if [[ "$(wc -l <"$f_linter_output")" -gt 30 ]]; then
            #
            # prepending output with linter name, since when displaying
            # output in fullecreen the previous lines indicating such is not
            # visible
            #
            printf '0a\nProject linter used:\n%s\n\n.\nw\n' \
                "${proj_linter_cmd["$linter"]}" | ed -s "$f_linter_output"
            less -R "$f_linter_output"
        else
            cat "$f_linter_output"
        fi
        handle_linting_error
    fi
    return 1
}

handle_linting_error() {
    #
    #  Either write out already processed files to cache and then exit
    #  or continue based upon
    #
    log_it "handle_linting_error()" "$dbglvl_major_tasks"
    $b_lint_continue && return
    env_cleanup 2
}

show_linter_action() {
    #
    #  Display what linter is used and what file is processed
    #
    local linter="$1"
    local fname="$2"

    # Print using printf with fixed-width formatting
    printf '%-17s: %s  ' "$linter" "$fname"
    t_lint_start="$(date +%s)"
}

log_processing_statistics() {
    local l_fname
    if [[ -n "$1" ]]; then
        l_fname="$1" # if param is provided use instead of fname
    else
        l_fname="$fname"
    fi
    # printf 'linter: %s \t%s \t%s\n' "$duration" "$linter" "$fname"
    sql_log_lint_stats "$linter" "$l_fname" "$duration"
}

show_linter_time() {
    local fname_override="$1"
    local duration

    duration=$(($(date +%s) - t_lint_start))
    $b_use_statistics && log_processing_statistics "$fname_override"
    if [[ "$duration" -ge "$long_lint_time" ]]; then
        printf ' - '
        display_time_elapsed "$duration"
    fi
    echo # always apply a LF
}

#---------------------------------------------------------------
#
#   SQL tasks
#
#---------------------------------------------------------------

sqlite_err_handling() {
    #
    #  If SQLITE_BUSY is detected, two more attempt is done after a sleep
    #  other error handling should be done by the caller
    #
    #  Loggs sqlite errors to $f_sqlite_error
    #
    #  Variables provided:
    #    sqlite_result    - Output from query
    #
    local sql="$1"
    local sqlite_exit_code

    log_it "sqlite_err_handling([$sql])" 1
    [[ -z "$sql" ]] && error_msg "sqlite_err_handling() - no param"

    # log_it "sqlite_err_handling()" -1

    if $b_log_sql; then # set to true to log sql queries
        # this does some filtering to give a more meaningful summary
        local sql_filtered
        sql_filtered="$(echo "$sql" \
            | sed 's/BEGIN TRANSACTION; -- Start the transaction//' \
            | tr -d '\n' | tr -s ' ' | sed 's/^ //' | sed 's/ ;/;/g' \
            | sed 's/; /;/g' | cut -c 1-50)"
        log_it "SQL:$sql_filtered" -1
    fi

    # shellcheck disable=SC2034
    sqlite_result="$(sqlite3 "$f_sqlite_db" "$sql" 2>"$f_sqlite_error")"
    sqlite_exit_code=$?

    case "$sqlite_exit_code" in
        0)
            [[ -f "$f_sqlite_error" ]] && {
                log_it "><> present: $f_sqlite_error"
            }
            ;; # no error
        *)
            #  log error but leave handling error up to caller
            local e_msg
            e_msg="sqlite_err_handling()\n$sql\nerror code: $sqlite_exit_code\n"
            e_msg+="error msg:  $(cat "$f_sqlite_error")"
            error_msg "$e_msg" -1

            [[ ! -s "$f_sqlite_db" ]] && [[ -f "$f_sqlite_db" ]] && {
                #
                #  If DB was removed, then a sql action would fail but lead
                #  to an empty DB. By removing such, next call to
                #  display_losses will recreate it and restart monitoring
                #
                error_msg "DB empty, terminating"
            }
            ;;
    esac

    return "$sqlite_exit_code"
}

sqlite_transaction() {
    local sql_original="$1"
    local sql

    log_it "sqlite_transaction($sql_original)" -1
    sql="
        BEGIN TRANSACTION; -- Start the transaction

        $sql_original ;

        COMMIT; -- Commit the transaction
        "
    sqlite_err_handling "$sql"

    #
    #  this will exit true if $sqlite_err_handling is 0
    #  caller should check sqlite_exit_code or $? depending how this was
    #  called
    #
    return
}

sql_create_db() {
    local sql

    log_it "sql_create_db()" -1

    # [[ -f "$f_sqlite_db" ]] && {
    #     rm -f "$f_sqlite_db"
    #     log_it "old_db removed" -1
    # }
    #
    #  t_loss is limited to $cfg_history_size records, in order to make
    #  statistics consistent
    #
    sql="
    CREATE TABLE lint_stats (
        time_stamp TIMESTAMP DEFAULT (datetime('now')) NOT NULL,
        linter CHAR,
        fname CHAR,
        duration INT
    );

    PRAGMA journal_mode = WAL;
    PRAGMA user_version = $db_version;  -- replace DB if out of date
    "
    log_it "  - sql defined" -1
    sqlite_err_handling "$sql" || {
        _m="sqlite3 exited with: $sqlite_exit_code \n"
        _m="$_m when creating the DB"
        error_msg "$_m"
    }
    log_it "Created DB - user_version: $db_version" -1
}

sql_init() {
    log_it "sql_init($f_sqlite_db)" -1
    rm -rf "$f_sqlite_error"
    [[ ! -f "$f_sqlite_db" ]] && sql_create_db
}

sql_drop() {
    [[ -f "$f_sqlite_db" ]] && {
        echo "Removing: $f_sqlite_db"
        rm "$f_sqlite_db"
    }
}

# sql_cmd() {
#     # runs an sql cmd at existing db
#     local sql="$1"
#     [[ -z "$sql" ]] && error_msg "sql_cmd() - no param"
#     sqlite_err_handling "$sql"
# }

sql_log_lint_stats() {
    local linter="$1"
    local fname="$2"
    local duration="$3"
    local sql=
    sql="INSERT INTO lint_stats (linter, fname, duration) "
    sql+="values( '$linter', '$fname', $duration)"
    sqlite_err_handling "$sql"
}

#---------------------------------------------------------------
#
#   Process files
#
#---------------------------------------------------------------

generate_list_of_files_to_process() {
    #
    #  Sets all_files to be a reverse chronological order list
    #  of all files in the current file tree
    #
    log_it "generate_list_of_files_to_process()" "$dbglvl_data_types"

    [[ "$verbosity_lvl" -ge 1 ]] && printf "Generating sorted tree of all files..."

    if [[ $kernel_name == "Darwin" ]]; then
        # macOS version
        # shellcheck disable=SC2207
        mapfile -t all_files < <(find . -type f -exec stat -f '%m %N' {} + \
            | sort -n -r -k1,1 | cut -d' ' -f2- | sed 's#^\./##')
    else
        if [[ "$running_on_ish" -eq 1 ]]; then
            #
            #  iSH kernel doesn't support enough of /proc to make mapfile work
            #
            # shellcheck disable=SC2207
            all_files=($(find . -type f -printf '%T@ %P\n' \
                | sort -n -r -k1,1 | cut -d' ' -f2-))
        else
            mapfile -t all_files < <(find . -type f -printf '%T@ %P\n' \
                | sort -n -r -k1,1 | cut -d' ' -f2-)
        fi
    fi
    log_it "all_files:" "$dbglvl_data_types"
    for f in "${all_files[@]}"; do
        log_it "  $f" "$dbglvl_data_types"
    done
    [[ "$verbosity_lvl" -ge 1 ]] && echo "done!"
}

show_excluded_file() {
    local excl_type="$1"
    local fname="$2"
    printf "%-16s: %s\n" "$excl_type" "$fname"
}

should_fname_be_excluded() {
    #
    #  Check if fname matches exclusion rules
    #
    local fname="$1"
    local item pattern rel_fname

    $b_skip_common_excludes && {
        for item in "${hidden_patterns[@]}"; do
            [[ $fname =~ $item ]] && return 0
        done
    }

    # Check if the filename matches any pattern
    for pattern in "${excluded_prefixes[@]}"; do
        [[ "$fname" =~ $pattern ]] && {
            $b_show_excluded && show_excluded_file "prefix" "$fname"
            return 0
        }
    done

    for item in "${excluded_suffixes[@]}"; do
        [[ "$fname" = *"$item" ]] && {
            $b_show_excluded && show_excluded_file "suffix" "$fname"
            return 0
        }
    done

    for item in "${excludes[@]}"; do
        [[ "$fname" = "$item" ]] && {
            $b_show_excluded && show_excluded_file "excludes" "$fname"
            return 0
        }
    done

    [[ -z "$plugin_def" ]] && {
        error_msg "check_linter_plugins() - found an empty \$fname"
    }
    rel_fname="$(basename "$fname")"
    for item in "${excluded_basenames[@]}"; do
        [[ "$rel_fname" = "$item" ]] && {
            $b_show_excluded && show_excluded_file "basename" "$fname"
            return 0
        }
    done

    for item in "${excluded_basename_prefixes[@]}"; do
        [[ "$rel_fname" = "$item"* ]] && {
            $b_show_excluded && {
                show_excluded_file "basename prefix" "$fname"
            }
            return 0
        }
    done

    return 1
}

ish_sysload_check() {
    # iSH crashes if sysload goes up to much, this pauses
    # until load is reasonable

    [[ -z "$ish_ift_uptime" ]] && return

    while [[ "$($ish_ift_uptime -l | cut -d. -f1)" -ge "$ish_max_load" ]]; do
        echo "***  iSH sysload is > $ish_max_load, waiting ${ish_high_load_sleep}s  ***"
        sleep "$ish_high_load_sleep"
    done
}

process_file_tree() {
    #
    #  Loop over al files, sorted by file age, newest firtst.
    #  Then identifying filetype using: file -b
    #  grouping by type, and linting files suitable for such
    #  as they come up. Thereby minimizing pointless wait time, since
    #  the file tree is globally sorted by age
    #
    local dbg_indent=$dbg_indent
    local all_files
    local fname
    local b_linter_found
    local file_types
    local file_type

    log_it "process_file_tree()" "$dbglvl_major_tasks"
    ((dbg_indent++)) # increase indent until this returns
    trap 'handle_ctrl_c INT' INT

    ! $b_proj_linters_only && {
        [[ "$running_on_ish" -eq 1 ]] && ish_sysload_check

        generate_list_of_files_to_process

        orig_dbg_indent=$dbg_indent
        cache_set_timer

        for fname in "${all_files[@]}"; do
            dbg_indent=$orig_dbg_indent
            [[ -z "$fname" ]] && continue

            b_linter_found=false
            [[ -d "$fname" ]] && continue

            should_fname_be_excluded "$fname" && continue
            $b_show_excluded && continue # only show excluded files, dont lint anything

            # abort if a time limit was set
            recent_enough "$fname" || {
                log_it "$fname too old to be processed" "$dbglvl_lint_file_basic"
                env_cleanup 0
            }

            log_it "Examining file: $fname" "$dbglvl_major_tasks"
            ((dbg_indent++)) # increase indent until this returns

            $b_use_cache && filename_is_cached "$fname" && {
                $b_lint_files && log_it "no changes : $fname" "$dbglvl_no_changes"
                continue
            }

            #
            #  Processing by file type
            #
            if $b_mime_type_limit; then
                file_cmd="file --mime-type -b"
            else
                file_cmd="file -b"
            fi
            IFS='|' read -r -a file_types <<<"$($file_cmd "$fname" \
                | tr '[:upper:]' '[:lower:]' | sed 's#, #|#g')"
            for file_type in "${file_types[@]}"; do
                [[ "$running_on_ish" -eq 1 ]] && ish_sysload_check
                lint_by_file_type "$file_type" "$fname" && {
                    b_linter_found=true
                    break
                }
            done
            $b_linter_found && continue

            #
            #  Processing by file extension
            #
            lint_by_ext "$fname" && {
                b_linter_found=true
                continue
            }

            $b_lint_files || {
                $b_linter_found || {
                    ((files_without_matching_linter++))
                    show_excluded_file "= No linter =" "$fname"
                }
            }
        done
    }

    $b_lint_files && ! $b_proj_linters_skip && ! $b_show_excluded \
        && [[ ${#proj_linters[@]} -gt 0 ]] && {

        ! $b_proj_linters_only && cache_set_timer

        for linter_name in "${proj_linters[@]}"; do
            [[ "$proj_lint_tasks_completed" == *"$linter_name"* ]] && continue

            # it would look ridiculous to first flush the cache then imeditally
            # write it again, so lets do it before the project lint
            maybe_update_cache

            [[ "$running_on_ish" -eq 1 ]] && ish_sysload_check
            lint_proj "$linter_name"
        done
    }

    trap '' INT # abort capturing Ctrl-C

    [[ $files_without_matching_linter -gt 0 ]] && {
        echo
        echo "Found $files_without_matching_linter files with no linter defined"
    }
}

#===============================================================
#
#   Main
#
#===============================================================

t_app_start=$(date +%s) # will be reset after a -Z cache clennse

#  Dependencies
[[ -z "$(command -v file)" ]] && {
    error_msg "Missing dependency: file" 1 no_cleanup
}

initialize_env
olint_venv_enable # Needs to happen before get_config
get_config "$1"
parse_cmd_line "$@"

[[ "$zap_it" -ne 0 ]] && {
    if [[ -f "$f_cache_file" ]]; then
        #  Will only attempt to remove the "local" same folder cache file
        echo "Removing $f_cache_file"
        rm -f "$f_cache_file"
    fi
    cache_folders=(
        .mypy_cache
        .pytest_cache
        .ruff_cache
    )
    for d_ceche_folder in "${cache_folders[@]}"; do
        if [[ -d "$d_ceche_folder" ]]; then
            echo "Removing: $d_ceche_folder"
            rm -rf "$d_ceche_folder"
        fi
    done
    [[ "$zap_it" -eq 1 ]] && sql_drop
    [[ "$zap_it" -eq 1 ]] && env_cleanup 0
    # restart timer after zapping to get correct linting time
    t_app_start=$(date +%s)
}

$b_use_statistics && sql_init

[[ "$verbosity_lvl" -gt 2 ]] && echo "Verbosity lvl is: $verbosity_lvl"

$b_show_help && {
    # In order to show list of hidden excludes, get_config must be called first
    show_help || error_msg "show_help() failure"
    env_cleanup 0
}

[[ "$running_on_ish" -eq 1 ]] && ish_sysload_check
if [[ -d "$olint_plugin_dir" ]]; then
    check_linter_plugins "$olint_plugin_dir"
else
    msg="Without plugins olint will not be able to do any linting!\n"
    msg+="No plugin folder found: $olint_plugin_dir"
    error_msg "$msg"
fi

$b_show_config && {
    display_config
    env_cleanup 0
}

should_project_be_ignored

$b_lint_continue && echo "Will continue with next file if linter found issues"
$b_use_cache || {
    echo "Will not use cache for checked files"
}

cache_read ### R
process_file_tree
env_cleanup 0
